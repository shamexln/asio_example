// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: medibus.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_medibus_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_medibus_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_medibus_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_medibus_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_medibus_2eproto;
namespace medibus {
class DeviceIdentificationRequest;
struct DeviceIdentificationRequestDefaultTypeInternal;
extern DeviceIdentificationRequestDefaultTypeInternal _DeviceIdentificationRequest_default_instance_;
class DeviceIdentificationRequest_DeviceRespond;
struct DeviceIdentificationRequest_DeviceRespondDefaultTypeInternal;
extern DeviceIdentificationRequest_DeviceRespondDefaultTypeInternal _DeviceIdentificationRequest_DeviceRespond_default_instance_;
class LoopRequest;
struct LoopRequestDefaultTypeInternal;
extern LoopRequestDefaultTypeInternal _LoopRequest_default_instance_;
class MedibusRealTimeRequest;
struct MedibusRealTimeRequestDefaultTypeInternal;
extern MedibusRealTimeRequestDefaultTypeInternal _MedibusRealTimeRequest_default_instance_;
class MedibusRealTimeRequest_DeviceRespond;
struct MedibusRealTimeRequest_DeviceRespondDefaultTypeInternal;
extern MedibusRealTimeRequest_DeviceRespondDefaultTypeInternal _MedibusRealTimeRequest_DeviceRespond_default_instance_;
class MedibusReply;
struct MedibusReplyDefaultTypeInternal;
extern MedibusReplyDefaultTypeInternal _MedibusReply_default_instance_;
class MedibusRequest;
struct MedibusRequestDefaultTypeInternal;
extern MedibusRequestDefaultTypeInternal _MedibusRequest_default_instance_;
class MedibusRequest_DeviceRespond;
struct MedibusRequest_DeviceRespondDefaultTypeInternal;
extern MedibusRequest_DeviceRespondDefaultTypeInternal _MedibusRequest_DeviceRespond_default_instance_;
}  // namespace medibus
PROTOBUF_NAMESPACE_OPEN
template<> ::medibus::DeviceIdentificationRequest* Arena::CreateMaybeMessage<::medibus::DeviceIdentificationRequest>(Arena*);
template<> ::medibus::DeviceIdentificationRequest_DeviceRespond* Arena::CreateMaybeMessage<::medibus::DeviceIdentificationRequest_DeviceRespond>(Arena*);
template<> ::medibus::LoopRequest* Arena::CreateMaybeMessage<::medibus::LoopRequest>(Arena*);
template<> ::medibus::MedibusRealTimeRequest* Arena::CreateMaybeMessage<::medibus::MedibusRealTimeRequest>(Arena*);
template<> ::medibus::MedibusRealTimeRequest_DeviceRespond* Arena::CreateMaybeMessage<::medibus::MedibusRealTimeRequest_DeviceRespond>(Arena*);
template<> ::medibus::MedibusReply* Arena::CreateMaybeMessage<::medibus::MedibusReply>(Arena*);
template<> ::medibus::MedibusRequest* Arena::CreateMaybeMessage<::medibus::MedibusRequest>(Arena*);
template<> ::medibus::MedibusRequest_DeviceRespond* Arena::CreateMaybeMessage<::medibus::MedibusRequest_DeviceRespond>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace medibus {

// ===================================================================

class DeviceIdentificationRequest_DeviceRespond final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:medibus.DeviceIdentificationRequest.DeviceRespond) */ {
 public:
  inline DeviceIdentificationRequest_DeviceRespond() : DeviceIdentificationRequest_DeviceRespond(nullptr) {}
  ~DeviceIdentificationRequest_DeviceRespond() override;
  explicit PROTOBUF_CONSTEXPR DeviceIdentificationRequest_DeviceRespond(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceIdentificationRequest_DeviceRespond(const DeviceIdentificationRequest_DeviceRespond& from);
  DeviceIdentificationRequest_DeviceRespond(DeviceIdentificationRequest_DeviceRespond&& from) noexcept
    : DeviceIdentificationRequest_DeviceRespond() {
    *this = ::std::move(from);
  }

  inline DeviceIdentificationRequest_DeviceRespond& operator=(const DeviceIdentificationRequest_DeviceRespond& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceIdentificationRequest_DeviceRespond& operator=(DeviceIdentificationRequest_DeviceRespond&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceIdentificationRequest_DeviceRespond& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceIdentificationRequest_DeviceRespond* internal_default_instance() {
    return reinterpret_cast<const DeviceIdentificationRequest_DeviceRespond*>(
               &_DeviceIdentificationRequest_DeviceRespond_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DeviceIdentificationRequest_DeviceRespond& a, DeviceIdentificationRequest_DeviceRespond& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceIdentificationRequest_DeviceRespond* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceIdentificationRequest_DeviceRespond* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceIdentificationRequest_DeviceRespond* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceIdentificationRequest_DeviceRespond>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeviceIdentificationRequest_DeviceRespond& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeviceIdentificationRequest_DeviceRespond& from) {
    DeviceIdentificationRequest_DeviceRespond::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceIdentificationRequest_DeviceRespond* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "medibus.DeviceIdentificationRequest.DeviceRespond";
  }
  protected:
  explicit DeviceIdentificationRequest_DeviceRespond(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceidFieldNumber = 1,
    kDevicenameFieldNumber = 2,
    kFacilityFieldNumber = 3,
    kPocFieldNumber = 4,
    kBedFieldNumber = 5,
    kRoomFieldNumber = 6,
    kBuildingFieldNumber = 7,
    kFloorFieldNumber = 8,
  };
  // optional string deviceid = 1;
  bool has_deviceid() const;
  private:
  bool _internal_has_deviceid() const;
  public:
  void clear_deviceid();
  const std::string& deviceid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_deviceid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_deviceid();
  PROTOBUF_NODISCARD std::string* release_deviceid();
  void set_allocated_deviceid(std::string* deviceid);
  private:
  const std::string& _internal_deviceid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deviceid(const std::string& value);
  std::string* _internal_mutable_deviceid();
  public:

  // optional string devicename = 2;
  bool has_devicename() const;
  private:
  bool _internal_has_devicename() const;
  public:
  void clear_devicename();
  const std::string& devicename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_devicename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_devicename();
  PROTOBUF_NODISCARD std::string* release_devicename();
  void set_allocated_devicename(std::string* devicename);
  private:
  const std::string& _internal_devicename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_devicename(const std::string& value);
  std::string* _internal_mutable_devicename();
  public:

  // optional string facility = 3;
  bool has_facility() const;
  private:
  bool _internal_has_facility() const;
  public:
  void clear_facility();
  const std::string& facility() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_facility(ArgT0&& arg0, ArgT... args);
  std::string* mutable_facility();
  PROTOBUF_NODISCARD std::string* release_facility();
  void set_allocated_facility(std::string* facility);
  private:
  const std::string& _internal_facility() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_facility(const std::string& value);
  std::string* _internal_mutable_facility();
  public:

  // optional string poc = 4;
  bool has_poc() const;
  private:
  bool _internal_has_poc() const;
  public:
  void clear_poc();
  const std::string& poc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_poc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_poc();
  PROTOBUF_NODISCARD std::string* release_poc();
  void set_allocated_poc(std::string* poc);
  private:
  const std::string& _internal_poc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_poc(const std::string& value);
  std::string* _internal_mutable_poc();
  public:

  // optional string bed = 5;
  bool has_bed() const;
  private:
  bool _internal_has_bed() const;
  public:
  void clear_bed();
  const std::string& bed() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bed(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bed();
  PROTOBUF_NODISCARD std::string* release_bed();
  void set_allocated_bed(std::string* bed);
  private:
  const std::string& _internal_bed() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bed(const std::string& value);
  std::string* _internal_mutable_bed();
  public:

  // optional string room = 6;
  bool has_room() const;
  private:
  bool _internal_has_room() const;
  public:
  void clear_room();
  const std::string& room() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_room(ArgT0&& arg0, ArgT... args);
  std::string* mutable_room();
  PROTOBUF_NODISCARD std::string* release_room();
  void set_allocated_room(std::string* room);
  private:
  const std::string& _internal_room() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_room(const std::string& value);
  std::string* _internal_mutable_room();
  public:

  // optional string building = 7;
  bool has_building() const;
  private:
  bool _internal_has_building() const;
  public:
  void clear_building();
  const std::string& building() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_building(ArgT0&& arg0, ArgT... args);
  std::string* mutable_building();
  PROTOBUF_NODISCARD std::string* release_building();
  void set_allocated_building(std::string* building);
  private:
  const std::string& _internal_building() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_building(const std::string& value);
  std::string* _internal_mutable_building();
  public:

  // optional string floor = 8;
  bool has_floor() const;
  private:
  bool _internal_has_floor() const;
  public:
  void clear_floor();
  const std::string& floor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_floor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_floor();
  PROTOBUF_NODISCARD std::string* release_floor();
  void set_allocated_floor(std::string* floor);
  private:
  const std::string& _internal_floor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_floor(const std::string& value);
  std::string* _internal_mutable_floor();
  public:

  // @@protoc_insertion_point(class_scope:medibus.DeviceIdentificationRequest.DeviceRespond)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deviceid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr devicename_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr facility_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr poc_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bed_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr room_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr building_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr floor_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_medibus_2eproto;
};
// -------------------------------------------------------------------

class DeviceIdentificationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:medibus.DeviceIdentificationRequest) */ {
 public:
  inline DeviceIdentificationRequest() : DeviceIdentificationRequest(nullptr) {}
  ~DeviceIdentificationRequest() override;
  explicit PROTOBUF_CONSTEXPR DeviceIdentificationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceIdentificationRequest(const DeviceIdentificationRequest& from);
  DeviceIdentificationRequest(DeviceIdentificationRequest&& from) noexcept
    : DeviceIdentificationRequest() {
    *this = ::std::move(from);
  }

  inline DeviceIdentificationRequest& operator=(const DeviceIdentificationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceIdentificationRequest& operator=(DeviceIdentificationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceIdentificationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceIdentificationRequest* internal_default_instance() {
    return reinterpret_cast<const DeviceIdentificationRequest*>(
               &_DeviceIdentificationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DeviceIdentificationRequest& a, DeviceIdentificationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceIdentificationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceIdentificationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceIdentificationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceIdentificationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeviceIdentificationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeviceIdentificationRequest& from) {
    DeviceIdentificationRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceIdentificationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "medibus.DeviceIdentificationRequest";
  }
  protected:
  explicit DeviceIdentificationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DeviceIdentificationRequest_DeviceRespond DeviceRespond;

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kDevicerespondsFieldNumber = 2,
  };
  // optional string id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // optional .medibus.DeviceIdentificationRequest.DeviceRespond deviceresponds = 2;
  bool has_deviceresponds() const;
  private:
  bool _internal_has_deviceresponds() const;
  public:
  void clear_deviceresponds();
  const ::medibus::DeviceIdentificationRequest_DeviceRespond& deviceresponds() const;
  PROTOBUF_NODISCARD ::medibus::DeviceIdentificationRequest_DeviceRespond* release_deviceresponds();
  ::medibus::DeviceIdentificationRequest_DeviceRespond* mutable_deviceresponds();
  void set_allocated_deviceresponds(::medibus::DeviceIdentificationRequest_DeviceRespond* deviceresponds);
  private:
  const ::medibus::DeviceIdentificationRequest_DeviceRespond& _internal_deviceresponds() const;
  ::medibus::DeviceIdentificationRequest_DeviceRespond* _internal_mutable_deviceresponds();
  public:
  void unsafe_arena_set_allocated_deviceresponds(
      ::medibus::DeviceIdentificationRequest_DeviceRespond* deviceresponds);
  ::medibus::DeviceIdentificationRequest_DeviceRespond* unsafe_arena_release_deviceresponds();

  // @@protoc_insertion_point(class_scope:medibus.DeviceIdentificationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::medibus::DeviceIdentificationRequest_DeviceRespond* deviceresponds_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_medibus_2eproto;
};
// -------------------------------------------------------------------

class MedibusRequest_DeviceRespond final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:medibus.MedibusRequest.DeviceRespond) */ {
 public:
  inline MedibusRequest_DeviceRespond() : MedibusRequest_DeviceRespond(nullptr) {}
  ~MedibusRequest_DeviceRespond() override;
  explicit PROTOBUF_CONSTEXPR MedibusRequest_DeviceRespond(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MedibusRequest_DeviceRespond(const MedibusRequest_DeviceRespond& from);
  MedibusRequest_DeviceRespond(MedibusRequest_DeviceRespond&& from) noexcept
    : MedibusRequest_DeviceRespond() {
    *this = ::std::move(from);
  }

  inline MedibusRequest_DeviceRespond& operator=(const MedibusRequest_DeviceRespond& from) {
    CopyFrom(from);
    return *this;
  }
  inline MedibusRequest_DeviceRespond& operator=(MedibusRequest_DeviceRespond&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MedibusRequest_DeviceRespond& default_instance() {
    return *internal_default_instance();
  }
  static inline const MedibusRequest_DeviceRespond* internal_default_instance() {
    return reinterpret_cast<const MedibusRequest_DeviceRespond*>(
               &_MedibusRequest_DeviceRespond_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MedibusRequest_DeviceRespond& a, MedibusRequest_DeviceRespond& b) {
    a.Swap(&b);
  }
  inline void Swap(MedibusRequest_DeviceRespond* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MedibusRequest_DeviceRespond* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MedibusRequest_DeviceRespond* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MedibusRequest_DeviceRespond>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MedibusRequest_DeviceRespond& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MedibusRequest_DeviceRespond& from) {
    MedibusRequest_DeviceRespond::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MedibusRequest_DeviceRespond* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "medibus.MedibusRequest.DeviceRespond";
  }
  protected:
  explicit MedibusRequest_DeviceRespond(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCodeFieldNumber = 1,
    kValueFieldNumber = 2,
    kUnitFieldNumber = 3,
    kDescriptionFieldNumber = 4,
  };
  // optional string code = 1;
  bool has_code() const;
  private:
  bool _internal_has_code() const;
  public:
  void clear_code();
  const std::string& code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_code();
  PROTOBUF_NODISCARD std::string* release_code();
  void set_allocated_code(std::string* code);
  private:
  const std::string& _internal_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code(const std::string& value);
  std::string* _internal_mutable_code();
  public:

  // optional string value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // optional string unit = 3;
  bool has_unit() const;
  private:
  bool _internal_has_unit() const;
  public:
  void clear_unit();
  const std::string& unit() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_unit(ArgT0&& arg0, ArgT... args);
  std::string* mutable_unit();
  PROTOBUF_NODISCARD std::string* release_unit();
  void set_allocated_unit(std::string* unit);
  private:
  const std::string& _internal_unit() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_unit(const std::string& value);
  std::string* _internal_mutable_unit();
  public:

  // optional string description = 4;
  bool has_description() const;
  private:
  bool _internal_has_description() const;
  public:
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // @@protoc_insertion_point(class_scope:medibus.MedibusRequest.DeviceRespond)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr unit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_medibus_2eproto;
};
// -------------------------------------------------------------------

class MedibusRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:medibus.MedibusRequest) */ {
 public:
  inline MedibusRequest() : MedibusRequest(nullptr) {}
  ~MedibusRequest() override;
  explicit PROTOBUF_CONSTEXPR MedibusRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MedibusRequest(const MedibusRequest& from);
  MedibusRequest(MedibusRequest&& from) noexcept
    : MedibusRequest() {
    *this = ::std::move(from);
  }

  inline MedibusRequest& operator=(const MedibusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MedibusRequest& operator=(MedibusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MedibusRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MedibusRequest* internal_default_instance() {
    return reinterpret_cast<const MedibusRequest*>(
               &_MedibusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MedibusRequest& a, MedibusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MedibusRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MedibusRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MedibusRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MedibusRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MedibusRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MedibusRequest& from) {
    MedibusRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MedibusRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "medibus.MedibusRequest";
  }
  protected:
  explicit MedibusRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MedibusRequest_DeviceRespond DeviceRespond;

  // accessors -------------------------------------------------------

  enum : int {
    kDevicerespondsFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // repeated .medibus.MedibusRequest.DeviceRespond deviceresponds = 2;
  int deviceresponds_size() const;
  private:
  int _internal_deviceresponds_size() const;
  public:
  void clear_deviceresponds();
  ::medibus::MedibusRequest_DeviceRespond* mutable_deviceresponds(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::medibus::MedibusRequest_DeviceRespond >*
      mutable_deviceresponds();
  private:
  const ::medibus::MedibusRequest_DeviceRespond& _internal_deviceresponds(int index) const;
  ::medibus::MedibusRequest_DeviceRespond* _internal_add_deviceresponds();
  public:
  const ::medibus::MedibusRequest_DeviceRespond& deviceresponds(int index) const;
  ::medibus::MedibusRequest_DeviceRespond* add_deviceresponds();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::medibus::MedibusRequest_DeviceRespond >&
      deviceresponds() const;

  // optional string id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:medibus.MedibusRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::medibus::MedibusRequest_DeviceRespond > deviceresponds_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_medibus_2eproto;
};
// -------------------------------------------------------------------

class MedibusReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:medibus.MedibusReply) */ {
 public:
  inline MedibusReply() : MedibusReply(nullptr) {}
  ~MedibusReply() override;
  explicit PROTOBUF_CONSTEXPR MedibusReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MedibusReply(const MedibusReply& from);
  MedibusReply(MedibusReply&& from) noexcept
    : MedibusReply() {
    *this = ::std::move(from);
  }

  inline MedibusReply& operator=(const MedibusReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline MedibusReply& operator=(MedibusReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MedibusReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const MedibusReply* internal_default_instance() {
    return reinterpret_cast<const MedibusReply*>(
               &_MedibusReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(MedibusReply& a, MedibusReply& b) {
    a.Swap(&b);
  }
  inline void Swap(MedibusReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MedibusReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MedibusReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MedibusReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MedibusReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MedibusReply& from) {
    MedibusReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MedibusReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "medibus.MedibusReply";
  }
  protected:
  explicit MedibusReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kMessageFieldNumber = 2,
  };
  // optional string id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:medibus.MedibusReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_medibus_2eproto;
};
// -------------------------------------------------------------------

class MedibusRealTimeRequest_DeviceRespond final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:medibus.MedibusRealTimeRequest.DeviceRespond) */ {
 public:
  inline MedibusRealTimeRequest_DeviceRespond() : MedibusRealTimeRequest_DeviceRespond(nullptr) {}
  ~MedibusRealTimeRequest_DeviceRespond() override;
  explicit PROTOBUF_CONSTEXPR MedibusRealTimeRequest_DeviceRespond(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MedibusRealTimeRequest_DeviceRespond(const MedibusRealTimeRequest_DeviceRespond& from);
  MedibusRealTimeRequest_DeviceRespond(MedibusRealTimeRequest_DeviceRespond&& from) noexcept
    : MedibusRealTimeRequest_DeviceRespond() {
    *this = ::std::move(from);
  }

  inline MedibusRealTimeRequest_DeviceRespond& operator=(const MedibusRealTimeRequest_DeviceRespond& from) {
    CopyFrom(from);
    return *this;
  }
  inline MedibusRealTimeRequest_DeviceRespond& operator=(MedibusRealTimeRequest_DeviceRespond&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MedibusRealTimeRequest_DeviceRespond& default_instance() {
    return *internal_default_instance();
  }
  static inline const MedibusRealTimeRequest_DeviceRespond* internal_default_instance() {
    return reinterpret_cast<const MedibusRealTimeRequest_DeviceRespond*>(
               &_MedibusRealTimeRequest_DeviceRespond_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(MedibusRealTimeRequest_DeviceRespond& a, MedibusRealTimeRequest_DeviceRespond& b) {
    a.Swap(&b);
  }
  inline void Swap(MedibusRealTimeRequest_DeviceRespond* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MedibusRealTimeRequest_DeviceRespond* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MedibusRealTimeRequest_DeviceRespond* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MedibusRealTimeRequest_DeviceRespond>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MedibusRealTimeRequest_DeviceRespond& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MedibusRealTimeRequest_DeviceRespond& from) {
    MedibusRealTimeRequest_DeviceRespond::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MedibusRealTimeRequest_DeviceRespond* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "medibus.MedibusRealTimeRequest.DeviceRespond";
  }
  protected:
  explicit MedibusRealTimeRequest_DeviceRespond(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinFieldNumber = 1,
    kMaxFieldNumber = 2,
    kMaxbinFieldNumber = 3,
    kIntervalFieldNumber = 4,
    kDescriptionFieldNumber = 5,
  };
  // optional string min = 1;
  bool has_min() const;
  private:
  bool _internal_has_min() const;
  public:
  void clear_min();
  const std::string& min() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_min(ArgT0&& arg0, ArgT... args);
  std::string* mutable_min();
  PROTOBUF_NODISCARD std::string* release_min();
  void set_allocated_min(std::string* min);
  private:
  const std::string& _internal_min() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_min(const std::string& value);
  std::string* _internal_mutable_min();
  public:

  // optional string max = 2;
  bool has_max() const;
  private:
  bool _internal_has_max() const;
  public:
  void clear_max();
  const std::string& max() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_max(ArgT0&& arg0, ArgT... args);
  std::string* mutable_max();
  PROTOBUF_NODISCARD std::string* release_max();
  void set_allocated_max(std::string* max);
  private:
  const std::string& _internal_max() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_max(const std::string& value);
  std::string* _internal_mutable_max();
  public:

  // optional string maxbin = 3;
  bool has_maxbin() const;
  private:
  bool _internal_has_maxbin() const;
  public:
  void clear_maxbin();
  const std::string& maxbin() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_maxbin(ArgT0&& arg0, ArgT... args);
  std::string* mutable_maxbin();
  PROTOBUF_NODISCARD std::string* release_maxbin();
  void set_allocated_maxbin(std::string* maxbin);
  private:
  const std::string& _internal_maxbin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_maxbin(const std::string& value);
  std::string* _internal_mutable_maxbin();
  public:

  // optional string interval = 4;
  bool has_interval() const;
  private:
  bool _internal_has_interval() const;
  public:
  void clear_interval();
  const std::string& interval() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_interval(ArgT0&& arg0, ArgT... args);
  std::string* mutable_interval();
  PROTOBUF_NODISCARD std::string* release_interval();
  void set_allocated_interval(std::string* interval);
  private:
  const std::string& _internal_interval() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_interval(const std::string& value);
  std::string* _internal_mutable_interval();
  public:

  // optional string description = 5;
  bool has_description() const;
  private:
  bool _internal_has_description() const;
  public:
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // @@protoc_insertion_point(class_scope:medibus.MedibusRealTimeRequest.DeviceRespond)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr min_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr max_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr maxbin_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr interval_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_medibus_2eproto;
};
// -------------------------------------------------------------------

class MedibusRealTimeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:medibus.MedibusRealTimeRequest) */ {
 public:
  inline MedibusRealTimeRequest() : MedibusRealTimeRequest(nullptr) {}
  ~MedibusRealTimeRequest() override;
  explicit PROTOBUF_CONSTEXPR MedibusRealTimeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MedibusRealTimeRequest(const MedibusRealTimeRequest& from);
  MedibusRealTimeRequest(MedibusRealTimeRequest&& from) noexcept
    : MedibusRealTimeRequest() {
    *this = ::std::move(from);
  }

  inline MedibusRealTimeRequest& operator=(const MedibusRealTimeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MedibusRealTimeRequest& operator=(MedibusRealTimeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MedibusRealTimeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MedibusRealTimeRequest* internal_default_instance() {
    return reinterpret_cast<const MedibusRealTimeRequest*>(
               &_MedibusRealTimeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MedibusRealTimeRequest& a, MedibusRealTimeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MedibusRealTimeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MedibusRealTimeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MedibusRealTimeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MedibusRealTimeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MedibusRealTimeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MedibusRealTimeRequest& from) {
    MedibusRealTimeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MedibusRealTimeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "medibus.MedibusRealTimeRequest";
  }
  protected:
  explicit MedibusRealTimeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MedibusRealTimeRequest_DeviceRespond DeviceRespond;

  // accessors -------------------------------------------------------

  enum : int {
    kDevicerespondsFieldNumber = 2,
    kIdFieldNumber = 1,
    kDescriptionFieldNumber = 3,
  };
  // repeated .medibus.MedibusRealTimeRequest.DeviceRespond deviceresponds = 2;
  int deviceresponds_size() const;
  private:
  int _internal_deviceresponds_size() const;
  public:
  void clear_deviceresponds();
  ::medibus::MedibusRealTimeRequest_DeviceRespond* mutable_deviceresponds(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::medibus::MedibusRealTimeRequest_DeviceRespond >*
      mutable_deviceresponds();
  private:
  const ::medibus::MedibusRealTimeRequest_DeviceRespond& _internal_deviceresponds(int index) const;
  ::medibus::MedibusRealTimeRequest_DeviceRespond* _internal_add_deviceresponds();
  public:
  const ::medibus::MedibusRealTimeRequest_DeviceRespond& deviceresponds(int index) const;
  ::medibus::MedibusRealTimeRequest_DeviceRespond* add_deviceresponds();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::medibus::MedibusRealTimeRequest_DeviceRespond >&
      deviceresponds() const;

  // optional string id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // optional string description = 3;
  bool has_description() const;
  private:
  bool _internal_has_description() const;
  public:
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // @@protoc_insertion_point(class_scope:medibus.MedibusRealTimeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::medibus::MedibusRealTimeRequest_DeviceRespond > deviceresponds_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_medibus_2eproto;
};
// -------------------------------------------------------------------

class LoopRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:medibus.LoopRequest) */ {
 public:
  inline LoopRequest() : LoopRequest(nullptr) {}
  ~LoopRequest() override;
  explicit PROTOBUF_CONSTEXPR LoopRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoopRequest(const LoopRequest& from);
  LoopRequest(LoopRequest&& from) noexcept
    : LoopRequest() {
    *this = ::std::move(from);
  }

  inline LoopRequest& operator=(const LoopRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoopRequest& operator=(LoopRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoopRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoopRequest* internal_default_instance() {
    return reinterpret_cast<const LoopRequest*>(
               &_LoopRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(LoopRequest& a, LoopRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LoopRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoopRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoopRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoopRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoopRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoopRequest& from) {
    LoopRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoopRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "medibus.LoopRequest";
  }
  protected:
  explicit LoopRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRealTimeFieldNumber = 13,
    kIdFieldNumber = 1,
    kCurMeasuredDataCP1FieldNumber = 2,
    kCurLowAlarmLimitsCP1FieldNumber = 3,
    kCurHighAlarmLimitsCP1FieldNumber = 4,
    kCurAlarmsCP1FieldNumber = 5,
    kCurDeviceSettingsFieldNumber = 6,
    kTextMessagesFieldNumber = 7,
    kCurMeasuredDataCP2FieldNumber = 8,
    kCurLowAlarmLimitsCP2FieldNumber = 9,
    kCurHighAlarmLimitsCP2FieldNumber = 10,
    kCurAlarmsCP2FieldNumber = 11,
    kDeviceIdentificationFieldNumber = 12,
  };
  // repeated .medibus.MedibusRealTimeRequest RealTime = 13;
  int realtime_size() const;
  private:
  int _internal_realtime_size() const;
  public:
  void clear_realtime();
  ::medibus::MedibusRealTimeRequest* mutable_realtime(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::medibus::MedibusRealTimeRequest >*
      mutable_realtime();
  private:
  const ::medibus::MedibusRealTimeRequest& _internal_realtime(int index) const;
  ::medibus::MedibusRealTimeRequest* _internal_add_realtime();
  public:
  const ::medibus::MedibusRealTimeRequest& realtime(int index) const;
  ::medibus::MedibusRealTimeRequest* add_realtime();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::medibus::MedibusRealTimeRequest >&
      realtime() const;

  // optional string id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // optional .medibus.MedibusRequest CurMeasuredDataCP1 = 2;
  bool has_curmeasureddatacp1() const;
  private:
  bool _internal_has_curmeasureddatacp1() const;
  public:
  void clear_curmeasureddatacp1();
  const ::medibus::MedibusRequest& curmeasureddatacp1() const;
  PROTOBUF_NODISCARD ::medibus::MedibusRequest* release_curmeasureddatacp1();
  ::medibus::MedibusRequest* mutable_curmeasureddatacp1();
  void set_allocated_curmeasureddatacp1(::medibus::MedibusRequest* curmeasureddatacp1);
  private:
  const ::medibus::MedibusRequest& _internal_curmeasureddatacp1() const;
  ::medibus::MedibusRequest* _internal_mutable_curmeasureddatacp1();
  public:
  void unsafe_arena_set_allocated_curmeasureddatacp1(
      ::medibus::MedibusRequest* curmeasureddatacp1);
  ::medibus::MedibusRequest* unsafe_arena_release_curmeasureddatacp1();

  // optional .medibus.MedibusRequest CurLowAlarmLimitsCP1 = 3;
  bool has_curlowalarmlimitscp1() const;
  private:
  bool _internal_has_curlowalarmlimitscp1() const;
  public:
  void clear_curlowalarmlimitscp1();
  const ::medibus::MedibusRequest& curlowalarmlimitscp1() const;
  PROTOBUF_NODISCARD ::medibus::MedibusRequest* release_curlowalarmlimitscp1();
  ::medibus::MedibusRequest* mutable_curlowalarmlimitscp1();
  void set_allocated_curlowalarmlimitscp1(::medibus::MedibusRequest* curlowalarmlimitscp1);
  private:
  const ::medibus::MedibusRequest& _internal_curlowalarmlimitscp1() const;
  ::medibus::MedibusRequest* _internal_mutable_curlowalarmlimitscp1();
  public:
  void unsafe_arena_set_allocated_curlowalarmlimitscp1(
      ::medibus::MedibusRequest* curlowalarmlimitscp1);
  ::medibus::MedibusRequest* unsafe_arena_release_curlowalarmlimitscp1();

  // optional .medibus.MedibusRequest CurHighAlarmLimitsCP1 = 4;
  bool has_curhighalarmlimitscp1() const;
  private:
  bool _internal_has_curhighalarmlimitscp1() const;
  public:
  void clear_curhighalarmlimitscp1();
  const ::medibus::MedibusRequest& curhighalarmlimitscp1() const;
  PROTOBUF_NODISCARD ::medibus::MedibusRequest* release_curhighalarmlimitscp1();
  ::medibus::MedibusRequest* mutable_curhighalarmlimitscp1();
  void set_allocated_curhighalarmlimitscp1(::medibus::MedibusRequest* curhighalarmlimitscp1);
  private:
  const ::medibus::MedibusRequest& _internal_curhighalarmlimitscp1() const;
  ::medibus::MedibusRequest* _internal_mutable_curhighalarmlimitscp1();
  public:
  void unsafe_arena_set_allocated_curhighalarmlimitscp1(
      ::medibus::MedibusRequest* curhighalarmlimitscp1);
  ::medibus::MedibusRequest* unsafe_arena_release_curhighalarmlimitscp1();

  // optional .medibus.MedibusRequest CurAlarmsCP1 = 5;
  bool has_curalarmscp1() const;
  private:
  bool _internal_has_curalarmscp1() const;
  public:
  void clear_curalarmscp1();
  const ::medibus::MedibusRequest& curalarmscp1() const;
  PROTOBUF_NODISCARD ::medibus::MedibusRequest* release_curalarmscp1();
  ::medibus::MedibusRequest* mutable_curalarmscp1();
  void set_allocated_curalarmscp1(::medibus::MedibusRequest* curalarmscp1);
  private:
  const ::medibus::MedibusRequest& _internal_curalarmscp1() const;
  ::medibus::MedibusRequest* _internal_mutable_curalarmscp1();
  public:
  void unsafe_arena_set_allocated_curalarmscp1(
      ::medibus::MedibusRequest* curalarmscp1);
  ::medibus::MedibusRequest* unsafe_arena_release_curalarmscp1();

  // optional .medibus.MedibusRequest CurDeviceSettings = 6;
  bool has_curdevicesettings() const;
  private:
  bool _internal_has_curdevicesettings() const;
  public:
  void clear_curdevicesettings();
  const ::medibus::MedibusRequest& curdevicesettings() const;
  PROTOBUF_NODISCARD ::medibus::MedibusRequest* release_curdevicesettings();
  ::medibus::MedibusRequest* mutable_curdevicesettings();
  void set_allocated_curdevicesettings(::medibus::MedibusRequest* curdevicesettings);
  private:
  const ::medibus::MedibusRequest& _internal_curdevicesettings() const;
  ::medibus::MedibusRequest* _internal_mutable_curdevicesettings();
  public:
  void unsafe_arena_set_allocated_curdevicesettings(
      ::medibus::MedibusRequest* curdevicesettings);
  ::medibus::MedibusRequest* unsafe_arena_release_curdevicesettings();

  // optional .medibus.MedibusRequest TextMessages = 7;
  bool has_textmessages() const;
  private:
  bool _internal_has_textmessages() const;
  public:
  void clear_textmessages();
  const ::medibus::MedibusRequest& textmessages() const;
  PROTOBUF_NODISCARD ::medibus::MedibusRequest* release_textmessages();
  ::medibus::MedibusRequest* mutable_textmessages();
  void set_allocated_textmessages(::medibus::MedibusRequest* textmessages);
  private:
  const ::medibus::MedibusRequest& _internal_textmessages() const;
  ::medibus::MedibusRequest* _internal_mutable_textmessages();
  public:
  void unsafe_arena_set_allocated_textmessages(
      ::medibus::MedibusRequest* textmessages);
  ::medibus::MedibusRequest* unsafe_arena_release_textmessages();

  // optional .medibus.MedibusRequest CurMeasuredDataCP2 = 8;
  bool has_curmeasureddatacp2() const;
  private:
  bool _internal_has_curmeasureddatacp2() const;
  public:
  void clear_curmeasureddatacp2();
  const ::medibus::MedibusRequest& curmeasureddatacp2() const;
  PROTOBUF_NODISCARD ::medibus::MedibusRequest* release_curmeasureddatacp2();
  ::medibus::MedibusRequest* mutable_curmeasureddatacp2();
  void set_allocated_curmeasureddatacp2(::medibus::MedibusRequest* curmeasureddatacp2);
  private:
  const ::medibus::MedibusRequest& _internal_curmeasureddatacp2() const;
  ::medibus::MedibusRequest* _internal_mutable_curmeasureddatacp2();
  public:
  void unsafe_arena_set_allocated_curmeasureddatacp2(
      ::medibus::MedibusRequest* curmeasureddatacp2);
  ::medibus::MedibusRequest* unsafe_arena_release_curmeasureddatacp2();

  // optional .medibus.MedibusRequest CurLowAlarmLimitsCP2 = 9;
  bool has_curlowalarmlimitscp2() const;
  private:
  bool _internal_has_curlowalarmlimitscp2() const;
  public:
  void clear_curlowalarmlimitscp2();
  const ::medibus::MedibusRequest& curlowalarmlimitscp2() const;
  PROTOBUF_NODISCARD ::medibus::MedibusRequest* release_curlowalarmlimitscp2();
  ::medibus::MedibusRequest* mutable_curlowalarmlimitscp2();
  void set_allocated_curlowalarmlimitscp2(::medibus::MedibusRequest* curlowalarmlimitscp2);
  private:
  const ::medibus::MedibusRequest& _internal_curlowalarmlimitscp2() const;
  ::medibus::MedibusRequest* _internal_mutable_curlowalarmlimitscp2();
  public:
  void unsafe_arena_set_allocated_curlowalarmlimitscp2(
      ::medibus::MedibusRequest* curlowalarmlimitscp2);
  ::medibus::MedibusRequest* unsafe_arena_release_curlowalarmlimitscp2();

  // optional .medibus.MedibusRequest CurHighAlarmLimitsCP2 = 10;
  bool has_curhighalarmlimitscp2() const;
  private:
  bool _internal_has_curhighalarmlimitscp2() const;
  public:
  void clear_curhighalarmlimitscp2();
  const ::medibus::MedibusRequest& curhighalarmlimitscp2() const;
  PROTOBUF_NODISCARD ::medibus::MedibusRequest* release_curhighalarmlimitscp2();
  ::medibus::MedibusRequest* mutable_curhighalarmlimitscp2();
  void set_allocated_curhighalarmlimitscp2(::medibus::MedibusRequest* curhighalarmlimitscp2);
  private:
  const ::medibus::MedibusRequest& _internal_curhighalarmlimitscp2() const;
  ::medibus::MedibusRequest* _internal_mutable_curhighalarmlimitscp2();
  public:
  void unsafe_arena_set_allocated_curhighalarmlimitscp2(
      ::medibus::MedibusRequest* curhighalarmlimitscp2);
  ::medibus::MedibusRequest* unsafe_arena_release_curhighalarmlimitscp2();

  // optional .medibus.MedibusRequest CurAlarmsCP2 = 11;
  bool has_curalarmscp2() const;
  private:
  bool _internal_has_curalarmscp2() const;
  public:
  void clear_curalarmscp2();
  const ::medibus::MedibusRequest& curalarmscp2() const;
  PROTOBUF_NODISCARD ::medibus::MedibusRequest* release_curalarmscp2();
  ::medibus::MedibusRequest* mutable_curalarmscp2();
  void set_allocated_curalarmscp2(::medibus::MedibusRequest* curalarmscp2);
  private:
  const ::medibus::MedibusRequest& _internal_curalarmscp2() const;
  ::medibus::MedibusRequest* _internal_mutable_curalarmscp2();
  public:
  void unsafe_arena_set_allocated_curalarmscp2(
      ::medibus::MedibusRequest* curalarmscp2);
  ::medibus::MedibusRequest* unsafe_arena_release_curalarmscp2();

  // optional .medibus.MedibusRequest DeviceIdentification = 12;
  bool has_deviceidentification() const;
  private:
  bool _internal_has_deviceidentification() const;
  public:
  void clear_deviceidentification();
  const ::medibus::MedibusRequest& deviceidentification() const;
  PROTOBUF_NODISCARD ::medibus::MedibusRequest* release_deviceidentification();
  ::medibus::MedibusRequest* mutable_deviceidentification();
  void set_allocated_deviceidentification(::medibus::MedibusRequest* deviceidentification);
  private:
  const ::medibus::MedibusRequest& _internal_deviceidentification() const;
  ::medibus::MedibusRequest* _internal_mutable_deviceidentification();
  public:
  void unsafe_arena_set_allocated_deviceidentification(
      ::medibus::MedibusRequest* deviceidentification);
  ::medibus::MedibusRequest* unsafe_arena_release_deviceidentification();

  // @@protoc_insertion_point(class_scope:medibus.LoopRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::medibus::MedibusRealTimeRequest > realtime_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::medibus::MedibusRequest* curmeasureddatacp1_;
    ::medibus::MedibusRequest* curlowalarmlimitscp1_;
    ::medibus::MedibusRequest* curhighalarmlimitscp1_;
    ::medibus::MedibusRequest* curalarmscp1_;
    ::medibus::MedibusRequest* curdevicesettings_;
    ::medibus::MedibusRequest* textmessages_;
    ::medibus::MedibusRequest* curmeasureddatacp2_;
    ::medibus::MedibusRequest* curlowalarmlimitscp2_;
    ::medibus::MedibusRequest* curhighalarmlimitscp2_;
    ::medibus::MedibusRequest* curalarmscp2_;
    ::medibus::MedibusRequest* deviceidentification_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_medibus_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DeviceIdentificationRequest_DeviceRespond

// optional string deviceid = 1;
inline bool DeviceIdentificationRequest_DeviceRespond::_internal_has_deviceid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceIdentificationRequest_DeviceRespond::has_deviceid() const {
  return _internal_has_deviceid();
}
inline void DeviceIdentificationRequest_DeviceRespond::clear_deviceid() {
  _impl_.deviceid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceIdentificationRequest_DeviceRespond::deviceid() const {
  // @@protoc_insertion_point(field_get:medibus.DeviceIdentificationRequest.DeviceRespond.deviceid)
  return _internal_deviceid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceIdentificationRequest_DeviceRespond::set_deviceid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.deviceid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:medibus.DeviceIdentificationRequest.DeviceRespond.deviceid)
}
inline std::string* DeviceIdentificationRequest_DeviceRespond::mutable_deviceid() {
  std::string* _s = _internal_mutable_deviceid();
  // @@protoc_insertion_point(field_mutable:medibus.DeviceIdentificationRequest.DeviceRespond.deviceid)
  return _s;
}
inline const std::string& DeviceIdentificationRequest_DeviceRespond::_internal_deviceid() const {
  return _impl_.deviceid_.Get();
}
inline void DeviceIdentificationRequest_DeviceRespond::_internal_set_deviceid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.deviceid_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceIdentificationRequest_DeviceRespond::_internal_mutable_deviceid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.deviceid_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceIdentificationRequest_DeviceRespond::release_deviceid() {
  // @@protoc_insertion_point(field_release:medibus.DeviceIdentificationRequest.DeviceRespond.deviceid)
  if (!_internal_has_deviceid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.deviceid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.deviceid_.IsDefault()) {
    _impl_.deviceid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceIdentificationRequest_DeviceRespond::set_allocated_deviceid(std::string* deviceid) {
  if (deviceid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.deviceid_.SetAllocated(deviceid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.deviceid_.IsDefault()) {
    _impl_.deviceid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:medibus.DeviceIdentificationRequest.DeviceRespond.deviceid)
}

// optional string devicename = 2;
inline bool DeviceIdentificationRequest_DeviceRespond::_internal_has_devicename() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DeviceIdentificationRequest_DeviceRespond::has_devicename() const {
  return _internal_has_devicename();
}
inline void DeviceIdentificationRequest_DeviceRespond::clear_devicename() {
  _impl_.devicename_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DeviceIdentificationRequest_DeviceRespond::devicename() const {
  // @@protoc_insertion_point(field_get:medibus.DeviceIdentificationRequest.DeviceRespond.devicename)
  return _internal_devicename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceIdentificationRequest_DeviceRespond::set_devicename(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.devicename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:medibus.DeviceIdentificationRequest.DeviceRespond.devicename)
}
inline std::string* DeviceIdentificationRequest_DeviceRespond::mutable_devicename() {
  std::string* _s = _internal_mutable_devicename();
  // @@protoc_insertion_point(field_mutable:medibus.DeviceIdentificationRequest.DeviceRespond.devicename)
  return _s;
}
inline const std::string& DeviceIdentificationRequest_DeviceRespond::_internal_devicename() const {
  return _impl_.devicename_.Get();
}
inline void DeviceIdentificationRequest_DeviceRespond::_internal_set_devicename(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.devicename_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceIdentificationRequest_DeviceRespond::_internal_mutable_devicename() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.devicename_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceIdentificationRequest_DeviceRespond::release_devicename() {
  // @@protoc_insertion_point(field_release:medibus.DeviceIdentificationRequest.DeviceRespond.devicename)
  if (!_internal_has_devicename()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.devicename_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.devicename_.IsDefault()) {
    _impl_.devicename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceIdentificationRequest_DeviceRespond::set_allocated_devicename(std::string* devicename) {
  if (devicename != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.devicename_.SetAllocated(devicename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.devicename_.IsDefault()) {
    _impl_.devicename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:medibus.DeviceIdentificationRequest.DeviceRespond.devicename)
}

// optional string facility = 3;
inline bool DeviceIdentificationRequest_DeviceRespond::_internal_has_facility() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DeviceIdentificationRequest_DeviceRespond::has_facility() const {
  return _internal_has_facility();
}
inline void DeviceIdentificationRequest_DeviceRespond::clear_facility() {
  _impl_.facility_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& DeviceIdentificationRequest_DeviceRespond::facility() const {
  // @@protoc_insertion_point(field_get:medibus.DeviceIdentificationRequest.DeviceRespond.facility)
  return _internal_facility();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceIdentificationRequest_DeviceRespond::set_facility(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.facility_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:medibus.DeviceIdentificationRequest.DeviceRespond.facility)
}
inline std::string* DeviceIdentificationRequest_DeviceRespond::mutable_facility() {
  std::string* _s = _internal_mutable_facility();
  // @@protoc_insertion_point(field_mutable:medibus.DeviceIdentificationRequest.DeviceRespond.facility)
  return _s;
}
inline const std::string& DeviceIdentificationRequest_DeviceRespond::_internal_facility() const {
  return _impl_.facility_.Get();
}
inline void DeviceIdentificationRequest_DeviceRespond::_internal_set_facility(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.facility_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceIdentificationRequest_DeviceRespond::_internal_mutable_facility() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.facility_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceIdentificationRequest_DeviceRespond::release_facility() {
  // @@protoc_insertion_point(field_release:medibus.DeviceIdentificationRequest.DeviceRespond.facility)
  if (!_internal_has_facility()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.facility_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.facility_.IsDefault()) {
    _impl_.facility_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceIdentificationRequest_DeviceRespond::set_allocated_facility(std::string* facility) {
  if (facility != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.facility_.SetAllocated(facility, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.facility_.IsDefault()) {
    _impl_.facility_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:medibus.DeviceIdentificationRequest.DeviceRespond.facility)
}

// optional string poc = 4;
inline bool DeviceIdentificationRequest_DeviceRespond::_internal_has_poc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DeviceIdentificationRequest_DeviceRespond::has_poc() const {
  return _internal_has_poc();
}
inline void DeviceIdentificationRequest_DeviceRespond::clear_poc() {
  _impl_.poc_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& DeviceIdentificationRequest_DeviceRespond::poc() const {
  // @@protoc_insertion_point(field_get:medibus.DeviceIdentificationRequest.DeviceRespond.poc)
  return _internal_poc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceIdentificationRequest_DeviceRespond::set_poc(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.poc_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:medibus.DeviceIdentificationRequest.DeviceRespond.poc)
}
inline std::string* DeviceIdentificationRequest_DeviceRespond::mutable_poc() {
  std::string* _s = _internal_mutable_poc();
  // @@protoc_insertion_point(field_mutable:medibus.DeviceIdentificationRequest.DeviceRespond.poc)
  return _s;
}
inline const std::string& DeviceIdentificationRequest_DeviceRespond::_internal_poc() const {
  return _impl_.poc_.Get();
}
inline void DeviceIdentificationRequest_DeviceRespond::_internal_set_poc(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.poc_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceIdentificationRequest_DeviceRespond::_internal_mutable_poc() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.poc_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceIdentificationRequest_DeviceRespond::release_poc() {
  // @@protoc_insertion_point(field_release:medibus.DeviceIdentificationRequest.DeviceRespond.poc)
  if (!_internal_has_poc()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.poc_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.poc_.IsDefault()) {
    _impl_.poc_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceIdentificationRequest_DeviceRespond::set_allocated_poc(std::string* poc) {
  if (poc != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.poc_.SetAllocated(poc, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.poc_.IsDefault()) {
    _impl_.poc_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:medibus.DeviceIdentificationRequest.DeviceRespond.poc)
}

// optional string bed = 5;
inline bool DeviceIdentificationRequest_DeviceRespond::_internal_has_bed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DeviceIdentificationRequest_DeviceRespond::has_bed() const {
  return _internal_has_bed();
}
inline void DeviceIdentificationRequest_DeviceRespond::clear_bed() {
  _impl_.bed_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& DeviceIdentificationRequest_DeviceRespond::bed() const {
  // @@protoc_insertion_point(field_get:medibus.DeviceIdentificationRequest.DeviceRespond.bed)
  return _internal_bed();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceIdentificationRequest_DeviceRespond::set_bed(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.bed_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:medibus.DeviceIdentificationRequest.DeviceRespond.bed)
}
inline std::string* DeviceIdentificationRequest_DeviceRespond::mutable_bed() {
  std::string* _s = _internal_mutable_bed();
  // @@protoc_insertion_point(field_mutable:medibus.DeviceIdentificationRequest.DeviceRespond.bed)
  return _s;
}
inline const std::string& DeviceIdentificationRequest_DeviceRespond::_internal_bed() const {
  return _impl_.bed_.Get();
}
inline void DeviceIdentificationRequest_DeviceRespond::_internal_set_bed(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.bed_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceIdentificationRequest_DeviceRespond::_internal_mutable_bed() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.bed_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceIdentificationRequest_DeviceRespond::release_bed() {
  // @@protoc_insertion_point(field_release:medibus.DeviceIdentificationRequest.DeviceRespond.bed)
  if (!_internal_has_bed()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.bed_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bed_.IsDefault()) {
    _impl_.bed_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceIdentificationRequest_DeviceRespond::set_allocated_bed(std::string* bed) {
  if (bed != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.bed_.SetAllocated(bed, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bed_.IsDefault()) {
    _impl_.bed_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:medibus.DeviceIdentificationRequest.DeviceRespond.bed)
}

// optional string room = 6;
inline bool DeviceIdentificationRequest_DeviceRespond::_internal_has_room() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool DeviceIdentificationRequest_DeviceRespond::has_room() const {
  return _internal_has_room();
}
inline void DeviceIdentificationRequest_DeviceRespond::clear_room() {
  _impl_.room_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& DeviceIdentificationRequest_DeviceRespond::room() const {
  // @@protoc_insertion_point(field_get:medibus.DeviceIdentificationRequest.DeviceRespond.room)
  return _internal_room();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceIdentificationRequest_DeviceRespond::set_room(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.room_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:medibus.DeviceIdentificationRequest.DeviceRespond.room)
}
inline std::string* DeviceIdentificationRequest_DeviceRespond::mutable_room() {
  std::string* _s = _internal_mutable_room();
  // @@protoc_insertion_point(field_mutable:medibus.DeviceIdentificationRequest.DeviceRespond.room)
  return _s;
}
inline const std::string& DeviceIdentificationRequest_DeviceRespond::_internal_room() const {
  return _impl_.room_.Get();
}
inline void DeviceIdentificationRequest_DeviceRespond::_internal_set_room(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.room_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceIdentificationRequest_DeviceRespond::_internal_mutable_room() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.room_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceIdentificationRequest_DeviceRespond::release_room() {
  // @@protoc_insertion_point(field_release:medibus.DeviceIdentificationRequest.DeviceRespond.room)
  if (!_internal_has_room()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.room_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.room_.IsDefault()) {
    _impl_.room_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceIdentificationRequest_DeviceRespond::set_allocated_room(std::string* room) {
  if (room != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.room_.SetAllocated(room, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.room_.IsDefault()) {
    _impl_.room_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:medibus.DeviceIdentificationRequest.DeviceRespond.room)
}

// optional string building = 7;
inline bool DeviceIdentificationRequest_DeviceRespond::_internal_has_building() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool DeviceIdentificationRequest_DeviceRespond::has_building() const {
  return _internal_has_building();
}
inline void DeviceIdentificationRequest_DeviceRespond::clear_building() {
  _impl_.building_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& DeviceIdentificationRequest_DeviceRespond::building() const {
  // @@protoc_insertion_point(field_get:medibus.DeviceIdentificationRequest.DeviceRespond.building)
  return _internal_building();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceIdentificationRequest_DeviceRespond::set_building(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000040u;
 _impl_.building_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:medibus.DeviceIdentificationRequest.DeviceRespond.building)
}
inline std::string* DeviceIdentificationRequest_DeviceRespond::mutable_building() {
  std::string* _s = _internal_mutable_building();
  // @@protoc_insertion_point(field_mutable:medibus.DeviceIdentificationRequest.DeviceRespond.building)
  return _s;
}
inline const std::string& DeviceIdentificationRequest_DeviceRespond::_internal_building() const {
  return _impl_.building_.Get();
}
inline void DeviceIdentificationRequest_DeviceRespond::_internal_set_building(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.building_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceIdentificationRequest_DeviceRespond::_internal_mutable_building() {
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.building_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceIdentificationRequest_DeviceRespond::release_building() {
  // @@protoc_insertion_point(field_release:medibus.DeviceIdentificationRequest.DeviceRespond.building)
  if (!_internal_has_building()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* p = _impl_.building_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.building_.IsDefault()) {
    _impl_.building_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceIdentificationRequest_DeviceRespond::set_allocated_building(std::string* building) {
  if (building != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.building_.SetAllocated(building, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.building_.IsDefault()) {
    _impl_.building_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:medibus.DeviceIdentificationRequest.DeviceRespond.building)
}

// optional string floor = 8;
inline bool DeviceIdentificationRequest_DeviceRespond::_internal_has_floor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool DeviceIdentificationRequest_DeviceRespond::has_floor() const {
  return _internal_has_floor();
}
inline void DeviceIdentificationRequest_DeviceRespond::clear_floor() {
  _impl_.floor_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& DeviceIdentificationRequest_DeviceRespond::floor() const {
  // @@protoc_insertion_point(field_get:medibus.DeviceIdentificationRequest.DeviceRespond.floor)
  return _internal_floor();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceIdentificationRequest_DeviceRespond::set_floor(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000080u;
 _impl_.floor_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:medibus.DeviceIdentificationRequest.DeviceRespond.floor)
}
inline std::string* DeviceIdentificationRequest_DeviceRespond::mutable_floor() {
  std::string* _s = _internal_mutable_floor();
  // @@protoc_insertion_point(field_mutable:medibus.DeviceIdentificationRequest.DeviceRespond.floor)
  return _s;
}
inline const std::string& DeviceIdentificationRequest_DeviceRespond::_internal_floor() const {
  return _impl_.floor_.Get();
}
inline void DeviceIdentificationRequest_DeviceRespond::_internal_set_floor(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.floor_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceIdentificationRequest_DeviceRespond::_internal_mutable_floor() {
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.floor_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceIdentificationRequest_DeviceRespond::release_floor() {
  // @@protoc_insertion_point(field_release:medibus.DeviceIdentificationRequest.DeviceRespond.floor)
  if (!_internal_has_floor()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* p = _impl_.floor_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.floor_.IsDefault()) {
    _impl_.floor_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceIdentificationRequest_DeviceRespond::set_allocated_floor(std::string* floor) {
  if (floor != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.floor_.SetAllocated(floor, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.floor_.IsDefault()) {
    _impl_.floor_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:medibus.DeviceIdentificationRequest.DeviceRespond.floor)
}

// -------------------------------------------------------------------

// DeviceIdentificationRequest

// optional string id = 1;
inline bool DeviceIdentificationRequest::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceIdentificationRequest::has_id() const {
  return _internal_has_id();
}
inline void DeviceIdentificationRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceIdentificationRequest::id() const {
  // @@protoc_insertion_point(field_get:medibus.DeviceIdentificationRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceIdentificationRequest::set_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:medibus.DeviceIdentificationRequest.id)
}
inline std::string* DeviceIdentificationRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:medibus.DeviceIdentificationRequest.id)
  return _s;
}
inline const std::string& DeviceIdentificationRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void DeviceIdentificationRequest::_internal_set_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceIdentificationRequest::_internal_mutable_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceIdentificationRequest::release_id() {
  // @@protoc_insertion_point(field_release:medibus.DeviceIdentificationRequest.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceIdentificationRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:medibus.DeviceIdentificationRequest.id)
}

// optional .medibus.DeviceIdentificationRequest.DeviceRespond deviceresponds = 2;
inline bool DeviceIdentificationRequest::_internal_has_deviceresponds() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.deviceresponds_ != nullptr);
  return value;
}
inline bool DeviceIdentificationRequest::has_deviceresponds() const {
  return _internal_has_deviceresponds();
}
inline void DeviceIdentificationRequest::clear_deviceresponds() {
  if (_impl_.deviceresponds_ != nullptr) _impl_.deviceresponds_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::medibus::DeviceIdentificationRequest_DeviceRespond& DeviceIdentificationRequest::_internal_deviceresponds() const {
  const ::medibus::DeviceIdentificationRequest_DeviceRespond* p = _impl_.deviceresponds_;
  return p != nullptr ? *p : reinterpret_cast<const ::medibus::DeviceIdentificationRequest_DeviceRespond&>(
      ::medibus::_DeviceIdentificationRequest_DeviceRespond_default_instance_);
}
inline const ::medibus::DeviceIdentificationRequest_DeviceRespond& DeviceIdentificationRequest::deviceresponds() const {
  // @@protoc_insertion_point(field_get:medibus.DeviceIdentificationRequest.deviceresponds)
  return _internal_deviceresponds();
}
inline void DeviceIdentificationRequest::unsafe_arena_set_allocated_deviceresponds(
    ::medibus::DeviceIdentificationRequest_DeviceRespond* deviceresponds) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.deviceresponds_);
  }
  _impl_.deviceresponds_ = deviceresponds;
  if (deviceresponds) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:medibus.DeviceIdentificationRequest.deviceresponds)
}
inline ::medibus::DeviceIdentificationRequest_DeviceRespond* DeviceIdentificationRequest::release_deviceresponds() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::medibus::DeviceIdentificationRequest_DeviceRespond* temp = _impl_.deviceresponds_;
  _impl_.deviceresponds_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::medibus::DeviceIdentificationRequest_DeviceRespond* DeviceIdentificationRequest::unsafe_arena_release_deviceresponds() {
  // @@protoc_insertion_point(field_release:medibus.DeviceIdentificationRequest.deviceresponds)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::medibus::DeviceIdentificationRequest_DeviceRespond* temp = _impl_.deviceresponds_;
  _impl_.deviceresponds_ = nullptr;
  return temp;
}
inline ::medibus::DeviceIdentificationRequest_DeviceRespond* DeviceIdentificationRequest::_internal_mutable_deviceresponds() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.deviceresponds_ == nullptr) {
    auto* p = CreateMaybeMessage<::medibus::DeviceIdentificationRequest_DeviceRespond>(GetArenaForAllocation());
    _impl_.deviceresponds_ = p;
  }
  return _impl_.deviceresponds_;
}
inline ::medibus::DeviceIdentificationRequest_DeviceRespond* DeviceIdentificationRequest::mutable_deviceresponds() {
  ::medibus::DeviceIdentificationRequest_DeviceRespond* _msg = _internal_mutable_deviceresponds();
  // @@protoc_insertion_point(field_mutable:medibus.DeviceIdentificationRequest.deviceresponds)
  return _msg;
}
inline void DeviceIdentificationRequest::set_allocated_deviceresponds(::medibus::DeviceIdentificationRequest_DeviceRespond* deviceresponds) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.deviceresponds_;
  }
  if (deviceresponds) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(deviceresponds);
    if (message_arena != submessage_arena) {
      deviceresponds = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, deviceresponds, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.deviceresponds_ = deviceresponds;
  // @@protoc_insertion_point(field_set_allocated:medibus.DeviceIdentificationRequest.deviceresponds)
}

// -------------------------------------------------------------------

// MedibusRequest_DeviceRespond

// optional string code = 1;
inline bool MedibusRequest_DeviceRespond::_internal_has_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MedibusRequest_DeviceRespond::has_code() const {
  return _internal_has_code();
}
inline void MedibusRequest_DeviceRespond::clear_code() {
  _impl_.code_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MedibusRequest_DeviceRespond::code() const {
  // @@protoc_insertion_point(field_get:medibus.MedibusRequest.DeviceRespond.code)
  return _internal_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MedibusRequest_DeviceRespond::set_code(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:medibus.MedibusRequest.DeviceRespond.code)
}
inline std::string* MedibusRequest_DeviceRespond::mutable_code() {
  std::string* _s = _internal_mutable_code();
  // @@protoc_insertion_point(field_mutable:medibus.MedibusRequest.DeviceRespond.code)
  return _s;
}
inline const std::string& MedibusRequest_DeviceRespond::_internal_code() const {
  return _impl_.code_.Get();
}
inline void MedibusRequest_DeviceRespond::_internal_set_code(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.code_.Set(value, GetArenaForAllocation());
}
inline std::string* MedibusRequest_DeviceRespond::_internal_mutable_code() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.code_.Mutable(GetArenaForAllocation());
}
inline std::string* MedibusRequest_DeviceRespond::release_code() {
  // @@protoc_insertion_point(field_release:medibus.MedibusRequest.DeviceRespond.code)
  if (!_internal_has_code()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.code_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.code_.IsDefault()) {
    _impl_.code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MedibusRequest_DeviceRespond::set_allocated_code(std::string* code) {
  if (code != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.code_.SetAllocated(code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.code_.IsDefault()) {
    _impl_.code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:medibus.MedibusRequest.DeviceRespond.code)
}

// optional string value = 2;
inline bool MedibusRequest_DeviceRespond::_internal_has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MedibusRequest_DeviceRespond::has_value() const {
  return _internal_has_value();
}
inline void MedibusRequest_DeviceRespond::clear_value() {
  _impl_.value_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MedibusRequest_DeviceRespond::value() const {
  // @@protoc_insertion_point(field_get:medibus.MedibusRequest.DeviceRespond.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MedibusRequest_DeviceRespond::set_value(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:medibus.MedibusRequest.DeviceRespond.value)
}
inline std::string* MedibusRequest_DeviceRespond::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:medibus.MedibusRequest.DeviceRespond.value)
  return _s;
}
inline const std::string& MedibusRequest_DeviceRespond::_internal_value() const {
  return _impl_.value_.Get();
}
inline void MedibusRequest_DeviceRespond::_internal_set_value(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* MedibusRequest_DeviceRespond::_internal_mutable_value() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* MedibusRequest_DeviceRespond::release_value() {
  // @@protoc_insertion_point(field_release:medibus.MedibusRequest.DeviceRespond.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.value_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MedibusRequest_DeviceRespond::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:medibus.MedibusRequest.DeviceRespond.value)
}

// optional string unit = 3;
inline bool MedibusRequest_DeviceRespond::_internal_has_unit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MedibusRequest_DeviceRespond::has_unit() const {
  return _internal_has_unit();
}
inline void MedibusRequest_DeviceRespond::clear_unit() {
  _impl_.unit_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& MedibusRequest_DeviceRespond::unit() const {
  // @@protoc_insertion_point(field_get:medibus.MedibusRequest.DeviceRespond.unit)
  return _internal_unit();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MedibusRequest_DeviceRespond::set_unit(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.unit_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:medibus.MedibusRequest.DeviceRespond.unit)
}
inline std::string* MedibusRequest_DeviceRespond::mutable_unit() {
  std::string* _s = _internal_mutable_unit();
  // @@protoc_insertion_point(field_mutable:medibus.MedibusRequest.DeviceRespond.unit)
  return _s;
}
inline const std::string& MedibusRequest_DeviceRespond::_internal_unit() const {
  return _impl_.unit_.Get();
}
inline void MedibusRequest_DeviceRespond::_internal_set_unit(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.unit_.Set(value, GetArenaForAllocation());
}
inline std::string* MedibusRequest_DeviceRespond::_internal_mutable_unit() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.unit_.Mutable(GetArenaForAllocation());
}
inline std::string* MedibusRequest_DeviceRespond::release_unit() {
  // @@protoc_insertion_point(field_release:medibus.MedibusRequest.DeviceRespond.unit)
  if (!_internal_has_unit()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.unit_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.unit_.IsDefault()) {
    _impl_.unit_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MedibusRequest_DeviceRespond::set_allocated_unit(std::string* unit) {
  if (unit != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.unit_.SetAllocated(unit, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.unit_.IsDefault()) {
    _impl_.unit_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:medibus.MedibusRequest.DeviceRespond.unit)
}

// optional string description = 4;
inline bool MedibusRequest_DeviceRespond::_internal_has_description() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MedibusRequest_DeviceRespond::has_description() const {
  return _internal_has_description();
}
inline void MedibusRequest_DeviceRespond::clear_description() {
  _impl_.description_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& MedibusRequest_DeviceRespond::description() const {
  // @@protoc_insertion_point(field_get:medibus.MedibusRequest.DeviceRespond.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MedibusRequest_DeviceRespond::set_description(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:medibus.MedibusRequest.DeviceRespond.description)
}
inline std::string* MedibusRequest_DeviceRespond::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:medibus.MedibusRequest.DeviceRespond.description)
  return _s;
}
inline const std::string& MedibusRequest_DeviceRespond::_internal_description() const {
  return _impl_.description_.Get();
}
inline void MedibusRequest_DeviceRespond::_internal_set_description(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* MedibusRequest_DeviceRespond::_internal_mutable_description() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* MedibusRequest_DeviceRespond::release_description() {
  // @@protoc_insertion_point(field_release:medibus.MedibusRequest.DeviceRespond.description)
  if (!_internal_has_description()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.description_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MedibusRequest_DeviceRespond::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:medibus.MedibusRequest.DeviceRespond.description)
}

// -------------------------------------------------------------------

// MedibusRequest

// optional string id = 1;
inline bool MedibusRequest::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MedibusRequest::has_id() const {
  return _internal_has_id();
}
inline void MedibusRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MedibusRequest::id() const {
  // @@protoc_insertion_point(field_get:medibus.MedibusRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MedibusRequest::set_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:medibus.MedibusRequest.id)
}
inline std::string* MedibusRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:medibus.MedibusRequest.id)
  return _s;
}
inline const std::string& MedibusRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void MedibusRequest::_internal_set_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* MedibusRequest::_internal_mutable_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* MedibusRequest::release_id() {
  // @@protoc_insertion_point(field_release:medibus.MedibusRequest.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MedibusRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:medibus.MedibusRequest.id)
}

// repeated .medibus.MedibusRequest.DeviceRespond deviceresponds = 2;
inline int MedibusRequest::_internal_deviceresponds_size() const {
  return _impl_.deviceresponds_.size();
}
inline int MedibusRequest::deviceresponds_size() const {
  return _internal_deviceresponds_size();
}
inline void MedibusRequest::clear_deviceresponds() {
  _impl_.deviceresponds_.Clear();
}
inline ::medibus::MedibusRequest_DeviceRespond* MedibusRequest::mutable_deviceresponds(int index) {
  // @@protoc_insertion_point(field_mutable:medibus.MedibusRequest.deviceresponds)
  return _impl_.deviceresponds_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::medibus::MedibusRequest_DeviceRespond >*
MedibusRequest::mutable_deviceresponds() {
  // @@protoc_insertion_point(field_mutable_list:medibus.MedibusRequest.deviceresponds)
  return &_impl_.deviceresponds_;
}
inline const ::medibus::MedibusRequest_DeviceRespond& MedibusRequest::_internal_deviceresponds(int index) const {
  return _impl_.deviceresponds_.Get(index);
}
inline const ::medibus::MedibusRequest_DeviceRespond& MedibusRequest::deviceresponds(int index) const {
  // @@protoc_insertion_point(field_get:medibus.MedibusRequest.deviceresponds)
  return _internal_deviceresponds(index);
}
inline ::medibus::MedibusRequest_DeviceRespond* MedibusRequest::_internal_add_deviceresponds() {
  return _impl_.deviceresponds_.Add();
}
inline ::medibus::MedibusRequest_DeviceRespond* MedibusRequest::add_deviceresponds() {
  ::medibus::MedibusRequest_DeviceRespond* _add = _internal_add_deviceresponds();
  // @@protoc_insertion_point(field_add:medibus.MedibusRequest.deviceresponds)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::medibus::MedibusRequest_DeviceRespond >&
MedibusRequest::deviceresponds() const {
  // @@protoc_insertion_point(field_list:medibus.MedibusRequest.deviceresponds)
  return _impl_.deviceresponds_;
}

// -------------------------------------------------------------------

// MedibusReply

// optional string id = 1;
inline bool MedibusReply::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MedibusReply::has_id() const {
  return _internal_has_id();
}
inline void MedibusReply::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MedibusReply::id() const {
  // @@protoc_insertion_point(field_get:medibus.MedibusReply.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MedibusReply::set_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:medibus.MedibusReply.id)
}
inline std::string* MedibusReply::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:medibus.MedibusReply.id)
  return _s;
}
inline const std::string& MedibusReply::_internal_id() const {
  return _impl_.id_.Get();
}
inline void MedibusReply::_internal_set_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* MedibusReply::_internal_mutable_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* MedibusReply::release_id() {
  // @@protoc_insertion_point(field_release:medibus.MedibusReply.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MedibusReply::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:medibus.MedibusReply.id)
}

// string message = 2;
inline void MedibusReply::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& MedibusReply::message() const {
  // @@protoc_insertion_point(field_get:medibus.MedibusReply.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MedibusReply::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:medibus.MedibusReply.message)
}
inline std::string* MedibusReply::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:medibus.MedibusReply.message)
  return _s;
}
inline const std::string& MedibusReply::_internal_message() const {
  return _impl_.message_.Get();
}
inline void MedibusReply::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* MedibusReply::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* MedibusReply::release_message() {
  // @@protoc_insertion_point(field_release:medibus.MedibusReply.message)
  return _impl_.message_.Release();
}
inline void MedibusReply::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:medibus.MedibusReply.message)
}

// -------------------------------------------------------------------

// MedibusRealTimeRequest_DeviceRespond

// optional string min = 1;
inline bool MedibusRealTimeRequest_DeviceRespond::_internal_has_min() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MedibusRealTimeRequest_DeviceRespond::has_min() const {
  return _internal_has_min();
}
inline void MedibusRealTimeRequest_DeviceRespond::clear_min() {
  _impl_.min_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MedibusRealTimeRequest_DeviceRespond::min() const {
  // @@protoc_insertion_point(field_get:medibus.MedibusRealTimeRequest.DeviceRespond.min)
  return _internal_min();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MedibusRealTimeRequest_DeviceRespond::set_min(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.min_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:medibus.MedibusRealTimeRequest.DeviceRespond.min)
}
inline std::string* MedibusRealTimeRequest_DeviceRespond::mutable_min() {
  std::string* _s = _internal_mutable_min();
  // @@protoc_insertion_point(field_mutable:medibus.MedibusRealTimeRequest.DeviceRespond.min)
  return _s;
}
inline const std::string& MedibusRealTimeRequest_DeviceRespond::_internal_min() const {
  return _impl_.min_.Get();
}
inline void MedibusRealTimeRequest_DeviceRespond::_internal_set_min(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.min_.Set(value, GetArenaForAllocation());
}
inline std::string* MedibusRealTimeRequest_DeviceRespond::_internal_mutable_min() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.min_.Mutable(GetArenaForAllocation());
}
inline std::string* MedibusRealTimeRequest_DeviceRespond::release_min() {
  // @@protoc_insertion_point(field_release:medibus.MedibusRealTimeRequest.DeviceRespond.min)
  if (!_internal_has_min()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.min_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.min_.IsDefault()) {
    _impl_.min_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MedibusRealTimeRequest_DeviceRespond::set_allocated_min(std::string* min) {
  if (min != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.min_.SetAllocated(min, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.min_.IsDefault()) {
    _impl_.min_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:medibus.MedibusRealTimeRequest.DeviceRespond.min)
}

// optional string max = 2;
inline bool MedibusRealTimeRequest_DeviceRespond::_internal_has_max() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MedibusRealTimeRequest_DeviceRespond::has_max() const {
  return _internal_has_max();
}
inline void MedibusRealTimeRequest_DeviceRespond::clear_max() {
  _impl_.max_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MedibusRealTimeRequest_DeviceRespond::max() const {
  // @@protoc_insertion_point(field_get:medibus.MedibusRealTimeRequest.DeviceRespond.max)
  return _internal_max();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MedibusRealTimeRequest_DeviceRespond::set_max(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.max_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:medibus.MedibusRealTimeRequest.DeviceRespond.max)
}
inline std::string* MedibusRealTimeRequest_DeviceRespond::mutable_max() {
  std::string* _s = _internal_mutable_max();
  // @@protoc_insertion_point(field_mutable:medibus.MedibusRealTimeRequest.DeviceRespond.max)
  return _s;
}
inline const std::string& MedibusRealTimeRequest_DeviceRespond::_internal_max() const {
  return _impl_.max_.Get();
}
inline void MedibusRealTimeRequest_DeviceRespond::_internal_set_max(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.max_.Set(value, GetArenaForAllocation());
}
inline std::string* MedibusRealTimeRequest_DeviceRespond::_internal_mutable_max() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.max_.Mutable(GetArenaForAllocation());
}
inline std::string* MedibusRealTimeRequest_DeviceRespond::release_max() {
  // @@protoc_insertion_point(field_release:medibus.MedibusRealTimeRequest.DeviceRespond.max)
  if (!_internal_has_max()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.max_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.max_.IsDefault()) {
    _impl_.max_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MedibusRealTimeRequest_DeviceRespond::set_allocated_max(std::string* max) {
  if (max != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.max_.SetAllocated(max, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.max_.IsDefault()) {
    _impl_.max_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:medibus.MedibusRealTimeRequest.DeviceRespond.max)
}

// optional string maxbin = 3;
inline bool MedibusRealTimeRequest_DeviceRespond::_internal_has_maxbin() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MedibusRealTimeRequest_DeviceRespond::has_maxbin() const {
  return _internal_has_maxbin();
}
inline void MedibusRealTimeRequest_DeviceRespond::clear_maxbin() {
  _impl_.maxbin_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& MedibusRealTimeRequest_DeviceRespond::maxbin() const {
  // @@protoc_insertion_point(field_get:medibus.MedibusRealTimeRequest.DeviceRespond.maxbin)
  return _internal_maxbin();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MedibusRealTimeRequest_DeviceRespond::set_maxbin(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.maxbin_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:medibus.MedibusRealTimeRequest.DeviceRespond.maxbin)
}
inline std::string* MedibusRealTimeRequest_DeviceRespond::mutable_maxbin() {
  std::string* _s = _internal_mutable_maxbin();
  // @@protoc_insertion_point(field_mutable:medibus.MedibusRealTimeRequest.DeviceRespond.maxbin)
  return _s;
}
inline const std::string& MedibusRealTimeRequest_DeviceRespond::_internal_maxbin() const {
  return _impl_.maxbin_.Get();
}
inline void MedibusRealTimeRequest_DeviceRespond::_internal_set_maxbin(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.maxbin_.Set(value, GetArenaForAllocation());
}
inline std::string* MedibusRealTimeRequest_DeviceRespond::_internal_mutable_maxbin() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.maxbin_.Mutable(GetArenaForAllocation());
}
inline std::string* MedibusRealTimeRequest_DeviceRespond::release_maxbin() {
  // @@protoc_insertion_point(field_release:medibus.MedibusRealTimeRequest.DeviceRespond.maxbin)
  if (!_internal_has_maxbin()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.maxbin_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.maxbin_.IsDefault()) {
    _impl_.maxbin_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MedibusRealTimeRequest_DeviceRespond::set_allocated_maxbin(std::string* maxbin) {
  if (maxbin != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.maxbin_.SetAllocated(maxbin, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.maxbin_.IsDefault()) {
    _impl_.maxbin_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:medibus.MedibusRealTimeRequest.DeviceRespond.maxbin)
}

// optional string interval = 4;
inline bool MedibusRealTimeRequest_DeviceRespond::_internal_has_interval() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MedibusRealTimeRequest_DeviceRespond::has_interval() const {
  return _internal_has_interval();
}
inline void MedibusRealTimeRequest_DeviceRespond::clear_interval() {
  _impl_.interval_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& MedibusRealTimeRequest_DeviceRespond::interval() const {
  // @@protoc_insertion_point(field_get:medibus.MedibusRealTimeRequest.DeviceRespond.interval)
  return _internal_interval();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MedibusRealTimeRequest_DeviceRespond::set_interval(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.interval_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:medibus.MedibusRealTimeRequest.DeviceRespond.interval)
}
inline std::string* MedibusRealTimeRequest_DeviceRespond::mutable_interval() {
  std::string* _s = _internal_mutable_interval();
  // @@protoc_insertion_point(field_mutable:medibus.MedibusRealTimeRequest.DeviceRespond.interval)
  return _s;
}
inline const std::string& MedibusRealTimeRequest_DeviceRespond::_internal_interval() const {
  return _impl_.interval_.Get();
}
inline void MedibusRealTimeRequest_DeviceRespond::_internal_set_interval(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.interval_.Set(value, GetArenaForAllocation());
}
inline std::string* MedibusRealTimeRequest_DeviceRespond::_internal_mutable_interval() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.interval_.Mutable(GetArenaForAllocation());
}
inline std::string* MedibusRealTimeRequest_DeviceRespond::release_interval() {
  // @@protoc_insertion_point(field_release:medibus.MedibusRealTimeRequest.DeviceRespond.interval)
  if (!_internal_has_interval()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.interval_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.interval_.IsDefault()) {
    _impl_.interval_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MedibusRealTimeRequest_DeviceRespond::set_allocated_interval(std::string* interval) {
  if (interval != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.interval_.SetAllocated(interval, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.interval_.IsDefault()) {
    _impl_.interval_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:medibus.MedibusRealTimeRequest.DeviceRespond.interval)
}

// optional string description = 5;
inline bool MedibusRealTimeRequest_DeviceRespond::_internal_has_description() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MedibusRealTimeRequest_DeviceRespond::has_description() const {
  return _internal_has_description();
}
inline void MedibusRealTimeRequest_DeviceRespond::clear_description() {
  _impl_.description_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& MedibusRealTimeRequest_DeviceRespond::description() const {
  // @@protoc_insertion_point(field_get:medibus.MedibusRealTimeRequest.DeviceRespond.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MedibusRealTimeRequest_DeviceRespond::set_description(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:medibus.MedibusRealTimeRequest.DeviceRespond.description)
}
inline std::string* MedibusRealTimeRequest_DeviceRespond::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:medibus.MedibusRealTimeRequest.DeviceRespond.description)
  return _s;
}
inline const std::string& MedibusRealTimeRequest_DeviceRespond::_internal_description() const {
  return _impl_.description_.Get();
}
inline void MedibusRealTimeRequest_DeviceRespond::_internal_set_description(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* MedibusRealTimeRequest_DeviceRespond::_internal_mutable_description() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* MedibusRealTimeRequest_DeviceRespond::release_description() {
  // @@protoc_insertion_point(field_release:medibus.MedibusRealTimeRequest.DeviceRespond.description)
  if (!_internal_has_description()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.description_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MedibusRealTimeRequest_DeviceRespond::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:medibus.MedibusRealTimeRequest.DeviceRespond.description)
}

// -------------------------------------------------------------------

// MedibusRealTimeRequest

// optional string id = 1;
inline bool MedibusRealTimeRequest::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MedibusRealTimeRequest::has_id() const {
  return _internal_has_id();
}
inline void MedibusRealTimeRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MedibusRealTimeRequest::id() const {
  // @@protoc_insertion_point(field_get:medibus.MedibusRealTimeRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MedibusRealTimeRequest::set_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:medibus.MedibusRealTimeRequest.id)
}
inline std::string* MedibusRealTimeRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:medibus.MedibusRealTimeRequest.id)
  return _s;
}
inline const std::string& MedibusRealTimeRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void MedibusRealTimeRequest::_internal_set_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* MedibusRealTimeRequest::_internal_mutable_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* MedibusRealTimeRequest::release_id() {
  // @@protoc_insertion_point(field_release:medibus.MedibusRealTimeRequest.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MedibusRealTimeRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:medibus.MedibusRealTimeRequest.id)
}

// repeated .medibus.MedibusRealTimeRequest.DeviceRespond deviceresponds = 2;
inline int MedibusRealTimeRequest::_internal_deviceresponds_size() const {
  return _impl_.deviceresponds_.size();
}
inline int MedibusRealTimeRequest::deviceresponds_size() const {
  return _internal_deviceresponds_size();
}
inline void MedibusRealTimeRequest::clear_deviceresponds() {
  _impl_.deviceresponds_.Clear();
}
inline ::medibus::MedibusRealTimeRequest_DeviceRespond* MedibusRealTimeRequest::mutable_deviceresponds(int index) {
  // @@protoc_insertion_point(field_mutable:medibus.MedibusRealTimeRequest.deviceresponds)
  return _impl_.deviceresponds_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::medibus::MedibusRealTimeRequest_DeviceRespond >*
MedibusRealTimeRequest::mutable_deviceresponds() {
  // @@protoc_insertion_point(field_mutable_list:medibus.MedibusRealTimeRequest.deviceresponds)
  return &_impl_.deviceresponds_;
}
inline const ::medibus::MedibusRealTimeRequest_DeviceRespond& MedibusRealTimeRequest::_internal_deviceresponds(int index) const {
  return _impl_.deviceresponds_.Get(index);
}
inline const ::medibus::MedibusRealTimeRequest_DeviceRespond& MedibusRealTimeRequest::deviceresponds(int index) const {
  // @@protoc_insertion_point(field_get:medibus.MedibusRealTimeRequest.deviceresponds)
  return _internal_deviceresponds(index);
}
inline ::medibus::MedibusRealTimeRequest_DeviceRespond* MedibusRealTimeRequest::_internal_add_deviceresponds() {
  return _impl_.deviceresponds_.Add();
}
inline ::medibus::MedibusRealTimeRequest_DeviceRespond* MedibusRealTimeRequest::add_deviceresponds() {
  ::medibus::MedibusRealTimeRequest_DeviceRespond* _add = _internal_add_deviceresponds();
  // @@protoc_insertion_point(field_add:medibus.MedibusRealTimeRequest.deviceresponds)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::medibus::MedibusRealTimeRequest_DeviceRespond >&
MedibusRealTimeRequest::deviceresponds() const {
  // @@protoc_insertion_point(field_list:medibus.MedibusRealTimeRequest.deviceresponds)
  return _impl_.deviceresponds_;
}

// optional string description = 3;
inline bool MedibusRealTimeRequest::_internal_has_description() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MedibusRealTimeRequest::has_description() const {
  return _internal_has_description();
}
inline void MedibusRealTimeRequest::clear_description() {
  _impl_.description_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MedibusRealTimeRequest::description() const {
  // @@protoc_insertion_point(field_get:medibus.MedibusRealTimeRequest.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MedibusRealTimeRequest::set_description(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:medibus.MedibusRealTimeRequest.description)
}
inline std::string* MedibusRealTimeRequest::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:medibus.MedibusRealTimeRequest.description)
  return _s;
}
inline const std::string& MedibusRealTimeRequest::_internal_description() const {
  return _impl_.description_.Get();
}
inline void MedibusRealTimeRequest::_internal_set_description(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* MedibusRealTimeRequest::_internal_mutable_description() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* MedibusRealTimeRequest::release_description() {
  // @@protoc_insertion_point(field_release:medibus.MedibusRealTimeRequest.description)
  if (!_internal_has_description()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.description_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MedibusRealTimeRequest::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:medibus.MedibusRealTimeRequest.description)
}

// -------------------------------------------------------------------

// LoopRequest

// optional string id = 1;
inline bool LoopRequest::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LoopRequest::has_id() const {
  return _internal_has_id();
}
inline void LoopRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LoopRequest::id() const {
  // @@protoc_insertion_point(field_get:medibus.LoopRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoopRequest::set_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:medibus.LoopRequest.id)
}
inline std::string* LoopRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:medibus.LoopRequest.id)
  return _s;
}
inline const std::string& LoopRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void LoopRequest::_internal_set_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* LoopRequest::_internal_mutable_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* LoopRequest::release_id() {
  // @@protoc_insertion_point(field_release:medibus.LoopRequest.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LoopRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:medibus.LoopRequest.id)
}

// optional .medibus.MedibusRequest CurMeasuredDataCP1 = 2;
inline bool LoopRequest::_internal_has_curmeasureddatacp1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.curmeasureddatacp1_ != nullptr);
  return value;
}
inline bool LoopRequest::has_curmeasureddatacp1() const {
  return _internal_has_curmeasureddatacp1();
}
inline void LoopRequest::clear_curmeasureddatacp1() {
  if (_impl_.curmeasureddatacp1_ != nullptr) _impl_.curmeasureddatacp1_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::medibus::MedibusRequest& LoopRequest::_internal_curmeasureddatacp1() const {
  const ::medibus::MedibusRequest* p = _impl_.curmeasureddatacp1_;
  return p != nullptr ? *p : reinterpret_cast<const ::medibus::MedibusRequest&>(
      ::medibus::_MedibusRequest_default_instance_);
}
inline const ::medibus::MedibusRequest& LoopRequest::curmeasureddatacp1() const {
  // @@protoc_insertion_point(field_get:medibus.LoopRequest.CurMeasuredDataCP1)
  return _internal_curmeasureddatacp1();
}
inline void LoopRequest::unsafe_arena_set_allocated_curmeasureddatacp1(
    ::medibus::MedibusRequest* curmeasureddatacp1) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.curmeasureddatacp1_);
  }
  _impl_.curmeasureddatacp1_ = curmeasureddatacp1;
  if (curmeasureddatacp1) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:medibus.LoopRequest.CurMeasuredDataCP1)
}
inline ::medibus::MedibusRequest* LoopRequest::release_curmeasureddatacp1() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::medibus::MedibusRequest* temp = _impl_.curmeasureddatacp1_;
  _impl_.curmeasureddatacp1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::medibus::MedibusRequest* LoopRequest::unsafe_arena_release_curmeasureddatacp1() {
  // @@protoc_insertion_point(field_release:medibus.LoopRequest.CurMeasuredDataCP1)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::medibus::MedibusRequest* temp = _impl_.curmeasureddatacp1_;
  _impl_.curmeasureddatacp1_ = nullptr;
  return temp;
}
inline ::medibus::MedibusRequest* LoopRequest::_internal_mutable_curmeasureddatacp1() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.curmeasureddatacp1_ == nullptr) {
    auto* p = CreateMaybeMessage<::medibus::MedibusRequest>(GetArenaForAllocation());
    _impl_.curmeasureddatacp1_ = p;
  }
  return _impl_.curmeasureddatacp1_;
}
inline ::medibus::MedibusRequest* LoopRequest::mutable_curmeasureddatacp1() {
  ::medibus::MedibusRequest* _msg = _internal_mutable_curmeasureddatacp1();
  // @@protoc_insertion_point(field_mutable:medibus.LoopRequest.CurMeasuredDataCP1)
  return _msg;
}
inline void LoopRequest::set_allocated_curmeasureddatacp1(::medibus::MedibusRequest* curmeasureddatacp1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.curmeasureddatacp1_;
  }
  if (curmeasureddatacp1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(curmeasureddatacp1);
    if (message_arena != submessage_arena) {
      curmeasureddatacp1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, curmeasureddatacp1, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.curmeasureddatacp1_ = curmeasureddatacp1;
  // @@protoc_insertion_point(field_set_allocated:medibus.LoopRequest.CurMeasuredDataCP1)
}

// optional .medibus.MedibusRequest CurLowAlarmLimitsCP1 = 3;
inline bool LoopRequest::_internal_has_curlowalarmlimitscp1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.curlowalarmlimitscp1_ != nullptr);
  return value;
}
inline bool LoopRequest::has_curlowalarmlimitscp1() const {
  return _internal_has_curlowalarmlimitscp1();
}
inline void LoopRequest::clear_curlowalarmlimitscp1() {
  if (_impl_.curlowalarmlimitscp1_ != nullptr) _impl_.curlowalarmlimitscp1_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::medibus::MedibusRequest& LoopRequest::_internal_curlowalarmlimitscp1() const {
  const ::medibus::MedibusRequest* p = _impl_.curlowalarmlimitscp1_;
  return p != nullptr ? *p : reinterpret_cast<const ::medibus::MedibusRequest&>(
      ::medibus::_MedibusRequest_default_instance_);
}
inline const ::medibus::MedibusRequest& LoopRequest::curlowalarmlimitscp1() const {
  // @@protoc_insertion_point(field_get:medibus.LoopRequest.CurLowAlarmLimitsCP1)
  return _internal_curlowalarmlimitscp1();
}
inline void LoopRequest::unsafe_arena_set_allocated_curlowalarmlimitscp1(
    ::medibus::MedibusRequest* curlowalarmlimitscp1) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.curlowalarmlimitscp1_);
  }
  _impl_.curlowalarmlimitscp1_ = curlowalarmlimitscp1;
  if (curlowalarmlimitscp1) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:medibus.LoopRequest.CurLowAlarmLimitsCP1)
}
inline ::medibus::MedibusRequest* LoopRequest::release_curlowalarmlimitscp1() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::medibus::MedibusRequest* temp = _impl_.curlowalarmlimitscp1_;
  _impl_.curlowalarmlimitscp1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::medibus::MedibusRequest* LoopRequest::unsafe_arena_release_curlowalarmlimitscp1() {
  // @@protoc_insertion_point(field_release:medibus.LoopRequest.CurLowAlarmLimitsCP1)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::medibus::MedibusRequest* temp = _impl_.curlowalarmlimitscp1_;
  _impl_.curlowalarmlimitscp1_ = nullptr;
  return temp;
}
inline ::medibus::MedibusRequest* LoopRequest::_internal_mutable_curlowalarmlimitscp1() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.curlowalarmlimitscp1_ == nullptr) {
    auto* p = CreateMaybeMessage<::medibus::MedibusRequest>(GetArenaForAllocation());
    _impl_.curlowalarmlimitscp1_ = p;
  }
  return _impl_.curlowalarmlimitscp1_;
}
inline ::medibus::MedibusRequest* LoopRequest::mutable_curlowalarmlimitscp1() {
  ::medibus::MedibusRequest* _msg = _internal_mutable_curlowalarmlimitscp1();
  // @@protoc_insertion_point(field_mutable:medibus.LoopRequest.CurLowAlarmLimitsCP1)
  return _msg;
}
inline void LoopRequest::set_allocated_curlowalarmlimitscp1(::medibus::MedibusRequest* curlowalarmlimitscp1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.curlowalarmlimitscp1_;
  }
  if (curlowalarmlimitscp1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(curlowalarmlimitscp1);
    if (message_arena != submessage_arena) {
      curlowalarmlimitscp1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, curlowalarmlimitscp1, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.curlowalarmlimitscp1_ = curlowalarmlimitscp1;
  // @@protoc_insertion_point(field_set_allocated:medibus.LoopRequest.CurLowAlarmLimitsCP1)
}

// optional .medibus.MedibusRequest CurHighAlarmLimitsCP1 = 4;
inline bool LoopRequest::_internal_has_curhighalarmlimitscp1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.curhighalarmlimitscp1_ != nullptr);
  return value;
}
inline bool LoopRequest::has_curhighalarmlimitscp1() const {
  return _internal_has_curhighalarmlimitscp1();
}
inline void LoopRequest::clear_curhighalarmlimitscp1() {
  if (_impl_.curhighalarmlimitscp1_ != nullptr) _impl_.curhighalarmlimitscp1_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::medibus::MedibusRequest& LoopRequest::_internal_curhighalarmlimitscp1() const {
  const ::medibus::MedibusRequest* p = _impl_.curhighalarmlimitscp1_;
  return p != nullptr ? *p : reinterpret_cast<const ::medibus::MedibusRequest&>(
      ::medibus::_MedibusRequest_default_instance_);
}
inline const ::medibus::MedibusRequest& LoopRequest::curhighalarmlimitscp1() const {
  // @@protoc_insertion_point(field_get:medibus.LoopRequest.CurHighAlarmLimitsCP1)
  return _internal_curhighalarmlimitscp1();
}
inline void LoopRequest::unsafe_arena_set_allocated_curhighalarmlimitscp1(
    ::medibus::MedibusRequest* curhighalarmlimitscp1) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.curhighalarmlimitscp1_);
  }
  _impl_.curhighalarmlimitscp1_ = curhighalarmlimitscp1;
  if (curhighalarmlimitscp1) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:medibus.LoopRequest.CurHighAlarmLimitsCP1)
}
inline ::medibus::MedibusRequest* LoopRequest::release_curhighalarmlimitscp1() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::medibus::MedibusRequest* temp = _impl_.curhighalarmlimitscp1_;
  _impl_.curhighalarmlimitscp1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::medibus::MedibusRequest* LoopRequest::unsafe_arena_release_curhighalarmlimitscp1() {
  // @@protoc_insertion_point(field_release:medibus.LoopRequest.CurHighAlarmLimitsCP1)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::medibus::MedibusRequest* temp = _impl_.curhighalarmlimitscp1_;
  _impl_.curhighalarmlimitscp1_ = nullptr;
  return temp;
}
inline ::medibus::MedibusRequest* LoopRequest::_internal_mutable_curhighalarmlimitscp1() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.curhighalarmlimitscp1_ == nullptr) {
    auto* p = CreateMaybeMessage<::medibus::MedibusRequest>(GetArenaForAllocation());
    _impl_.curhighalarmlimitscp1_ = p;
  }
  return _impl_.curhighalarmlimitscp1_;
}
inline ::medibus::MedibusRequest* LoopRequest::mutable_curhighalarmlimitscp1() {
  ::medibus::MedibusRequest* _msg = _internal_mutable_curhighalarmlimitscp1();
  // @@protoc_insertion_point(field_mutable:medibus.LoopRequest.CurHighAlarmLimitsCP1)
  return _msg;
}
inline void LoopRequest::set_allocated_curhighalarmlimitscp1(::medibus::MedibusRequest* curhighalarmlimitscp1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.curhighalarmlimitscp1_;
  }
  if (curhighalarmlimitscp1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(curhighalarmlimitscp1);
    if (message_arena != submessage_arena) {
      curhighalarmlimitscp1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, curhighalarmlimitscp1, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.curhighalarmlimitscp1_ = curhighalarmlimitscp1;
  // @@protoc_insertion_point(field_set_allocated:medibus.LoopRequest.CurHighAlarmLimitsCP1)
}

// optional .medibus.MedibusRequest CurAlarmsCP1 = 5;
inline bool LoopRequest::_internal_has_curalarmscp1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.curalarmscp1_ != nullptr);
  return value;
}
inline bool LoopRequest::has_curalarmscp1() const {
  return _internal_has_curalarmscp1();
}
inline void LoopRequest::clear_curalarmscp1() {
  if (_impl_.curalarmscp1_ != nullptr) _impl_.curalarmscp1_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::medibus::MedibusRequest& LoopRequest::_internal_curalarmscp1() const {
  const ::medibus::MedibusRequest* p = _impl_.curalarmscp1_;
  return p != nullptr ? *p : reinterpret_cast<const ::medibus::MedibusRequest&>(
      ::medibus::_MedibusRequest_default_instance_);
}
inline const ::medibus::MedibusRequest& LoopRequest::curalarmscp1() const {
  // @@protoc_insertion_point(field_get:medibus.LoopRequest.CurAlarmsCP1)
  return _internal_curalarmscp1();
}
inline void LoopRequest::unsafe_arena_set_allocated_curalarmscp1(
    ::medibus::MedibusRequest* curalarmscp1) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.curalarmscp1_);
  }
  _impl_.curalarmscp1_ = curalarmscp1;
  if (curalarmscp1) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:medibus.LoopRequest.CurAlarmsCP1)
}
inline ::medibus::MedibusRequest* LoopRequest::release_curalarmscp1() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::medibus::MedibusRequest* temp = _impl_.curalarmscp1_;
  _impl_.curalarmscp1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::medibus::MedibusRequest* LoopRequest::unsafe_arena_release_curalarmscp1() {
  // @@protoc_insertion_point(field_release:medibus.LoopRequest.CurAlarmsCP1)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::medibus::MedibusRequest* temp = _impl_.curalarmscp1_;
  _impl_.curalarmscp1_ = nullptr;
  return temp;
}
inline ::medibus::MedibusRequest* LoopRequest::_internal_mutable_curalarmscp1() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.curalarmscp1_ == nullptr) {
    auto* p = CreateMaybeMessage<::medibus::MedibusRequest>(GetArenaForAllocation());
    _impl_.curalarmscp1_ = p;
  }
  return _impl_.curalarmscp1_;
}
inline ::medibus::MedibusRequest* LoopRequest::mutable_curalarmscp1() {
  ::medibus::MedibusRequest* _msg = _internal_mutable_curalarmscp1();
  // @@protoc_insertion_point(field_mutable:medibus.LoopRequest.CurAlarmsCP1)
  return _msg;
}
inline void LoopRequest::set_allocated_curalarmscp1(::medibus::MedibusRequest* curalarmscp1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.curalarmscp1_;
  }
  if (curalarmscp1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(curalarmscp1);
    if (message_arena != submessage_arena) {
      curalarmscp1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, curalarmscp1, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.curalarmscp1_ = curalarmscp1;
  // @@protoc_insertion_point(field_set_allocated:medibus.LoopRequest.CurAlarmsCP1)
}

// optional .medibus.MedibusRequest CurDeviceSettings = 6;
inline bool LoopRequest::_internal_has_curdevicesettings() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.curdevicesettings_ != nullptr);
  return value;
}
inline bool LoopRequest::has_curdevicesettings() const {
  return _internal_has_curdevicesettings();
}
inline void LoopRequest::clear_curdevicesettings() {
  if (_impl_.curdevicesettings_ != nullptr) _impl_.curdevicesettings_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::medibus::MedibusRequest& LoopRequest::_internal_curdevicesettings() const {
  const ::medibus::MedibusRequest* p = _impl_.curdevicesettings_;
  return p != nullptr ? *p : reinterpret_cast<const ::medibus::MedibusRequest&>(
      ::medibus::_MedibusRequest_default_instance_);
}
inline const ::medibus::MedibusRequest& LoopRequest::curdevicesettings() const {
  // @@protoc_insertion_point(field_get:medibus.LoopRequest.CurDeviceSettings)
  return _internal_curdevicesettings();
}
inline void LoopRequest::unsafe_arena_set_allocated_curdevicesettings(
    ::medibus::MedibusRequest* curdevicesettings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.curdevicesettings_);
  }
  _impl_.curdevicesettings_ = curdevicesettings;
  if (curdevicesettings) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:medibus.LoopRequest.CurDeviceSettings)
}
inline ::medibus::MedibusRequest* LoopRequest::release_curdevicesettings() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::medibus::MedibusRequest* temp = _impl_.curdevicesettings_;
  _impl_.curdevicesettings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::medibus::MedibusRequest* LoopRequest::unsafe_arena_release_curdevicesettings() {
  // @@protoc_insertion_point(field_release:medibus.LoopRequest.CurDeviceSettings)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::medibus::MedibusRequest* temp = _impl_.curdevicesettings_;
  _impl_.curdevicesettings_ = nullptr;
  return temp;
}
inline ::medibus::MedibusRequest* LoopRequest::_internal_mutable_curdevicesettings() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.curdevicesettings_ == nullptr) {
    auto* p = CreateMaybeMessage<::medibus::MedibusRequest>(GetArenaForAllocation());
    _impl_.curdevicesettings_ = p;
  }
  return _impl_.curdevicesettings_;
}
inline ::medibus::MedibusRequest* LoopRequest::mutable_curdevicesettings() {
  ::medibus::MedibusRequest* _msg = _internal_mutable_curdevicesettings();
  // @@protoc_insertion_point(field_mutable:medibus.LoopRequest.CurDeviceSettings)
  return _msg;
}
inline void LoopRequest::set_allocated_curdevicesettings(::medibus::MedibusRequest* curdevicesettings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.curdevicesettings_;
  }
  if (curdevicesettings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(curdevicesettings);
    if (message_arena != submessage_arena) {
      curdevicesettings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, curdevicesettings, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.curdevicesettings_ = curdevicesettings;
  // @@protoc_insertion_point(field_set_allocated:medibus.LoopRequest.CurDeviceSettings)
}

// optional .medibus.MedibusRequest TextMessages = 7;
inline bool LoopRequest::_internal_has_textmessages() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.textmessages_ != nullptr);
  return value;
}
inline bool LoopRequest::has_textmessages() const {
  return _internal_has_textmessages();
}
inline void LoopRequest::clear_textmessages() {
  if (_impl_.textmessages_ != nullptr) _impl_.textmessages_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::medibus::MedibusRequest& LoopRequest::_internal_textmessages() const {
  const ::medibus::MedibusRequest* p = _impl_.textmessages_;
  return p != nullptr ? *p : reinterpret_cast<const ::medibus::MedibusRequest&>(
      ::medibus::_MedibusRequest_default_instance_);
}
inline const ::medibus::MedibusRequest& LoopRequest::textmessages() const {
  // @@protoc_insertion_point(field_get:medibus.LoopRequest.TextMessages)
  return _internal_textmessages();
}
inline void LoopRequest::unsafe_arena_set_allocated_textmessages(
    ::medibus::MedibusRequest* textmessages) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.textmessages_);
  }
  _impl_.textmessages_ = textmessages;
  if (textmessages) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:medibus.LoopRequest.TextMessages)
}
inline ::medibus::MedibusRequest* LoopRequest::release_textmessages() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::medibus::MedibusRequest* temp = _impl_.textmessages_;
  _impl_.textmessages_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::medibus::MedibusRequest* LoopRequest::unsafe_arena_release_textmessages() {
  // @@protoc_insertion_point(field_release:medibus.LoopRequest.TextMessages)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::medibus::MedibusRequest* temp = _impl_.textmessages_;
  _impl_.textmessages_ = nullptr;
  return temp;
}
inline ::medibus::MedibusRequest* LoopRequest::_internal_mutable_textmessages() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.textmessages_ == nullptr) {
    auto* p = CreateMaybeMessage<::medibus::MedibusRequest>(GetArenaForAllocation());
    _impl_.textmessages_ = p;
  }
  return _impl_.textmessages_;
}
inline ::medibus::MedibusRequest* LoopRequest::mutable_textmessages() {
  ::medibus::MedibusRequest* _msg = _internal_mutable_textmessages();
  // @@protoc_insertion_point(field_mutable:medibus.LoopRequest.TextMessages)
  return _msg;
}
inline void LoopRequest::set_allocated_textmessages(::medibus::MedibusRequest* textmessages) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.textmessages_;
  }
  if (textmessages) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(textmessages);
    if (message_arena != submessage_arena) {
      textmessages = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, textmessages, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.textmessages_ = textmessages;
  // @@protoc_insertion_point(field_set_allocated:medibus.LoopRequest.TextMessages)
}

// optional .medibus.MedibusRequest CurMeasuredDataCP2 = 8;
inline bool LoopRequest::_internal_has_curmeasureddatacp2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.curmeasureddatacp2_ != nullptr);
  return value;
}
inline bool LoopRequest::has_curmeasureddatacp2() const {
  return _internal_has_curmeasureddatacp2();
}
inline void LoopRequest::clear_curmeasureddatacp2() {
  if (_impl_.curmeasureddatacp2_ != nullptr) _impl_.curmeasureddatacp2_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::medibus::MedibusRequest& LoopRequest::_internal_curmeasureddatacp2() const {
  const ::medibus::MedibusRequest* p = _impl_.curmeasureddatacp2_;
  return p != nullptr ? *p : reinterpret_cast<const ::medibus::MedibusRequest&>(
      ::medibus::_MedibusRequest_default_instance_);
}
inline const ::medibus::MedibusRequest& LoopRequest::curmeasureddatacp2() const {
  // @@protoc_insertion_point(field_get:medibus.LoopRequest.CurMeasuredDataCP2)
  return _internal_curmeasureddatacp2();
}
inline void LoopRequest::unsafe_arena_set_allocated_curmeasureddatacp2(
    ::medibus::MedibusRequest* curmeasureddatacp2) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.curmeasureddatacp2_);
  }
  _impl_.curmeasureddatacp2_ = curmeasureddatacp2;
  if (curmeasureddatacp2) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:medibus.LoopRequest.CurMeasuredDataCP2)
}
inline ::medibus::MedibusRequest* LoopRequest::release_curmeasureddatacp2() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::medibus::MedibusRequest* temp = _impl_.curmeasureddatacp2_;
  _impl_.curmeasureddatacp2_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::medibus::MedibusRequest* LoopRequest::unsafe_arena_release_curmeasureddatacp2() {
  // @@protoc_insertion_point(field_release:medibus.LoopRequest.CurMeasuredDataCP2)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::medibus::MedibusRequest* temp = _impl_.curmeasureddatacp2_;
  _impl_.curmeasureddatacp2_ = nullptr;
  return temp;
}
inline ::medibus::MedibusRequest* LoopRequest::_internal_mutable_curmeasureddatacp2() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.curmeasureddatacp2_ == nullptr) {
    auto* p = CreateMaybeMessage<::medibus::MedibusRequest>(GetArenaForAllocation());
    _impl_.curmeasureddatacp2_ = p;
  }
  return _impl_.curmeasureddatacp2_;
}
inline ::medibus::MedibusRequest* LoopRequest::mutable_curmeasureddatacp2() {
  ::medibus::MedibusRequest* _msg = _internal_mutable_curmeasureddatacp2();
  // @@protoc_insertion_point(field_mutable:medibus.LoopRequest.CurMeasuredDataCP2)
  return _msg;
}
inline void LoopRequest::set_allocated_curmeasureddatacp2(::medibus::MedibusRequest* curmeasureddatacp2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.curmeasureddatacp2_;
  }
  if (curmeasureddatacp2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(curmeasureddatacp2);
    if (message_arena != submessage_arena) {
      curmeasureddatacp2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, curmeasureddatacp2, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.curmeasureddatacp2_ = curmeasureddatacp2;
  // @@protoc_insertion_point(field_set_allocated:medibus.LoopRequest.CurMeasuredDataCP2)
}

// optional .medibus.MedibusRequest CurLowAlarmLimitsCP2 = 9;
inline bool LoopRequest::_internal_has_curlowalarmlimitscp2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.curlowalarmlimitscp2_ != nullptr);
  return value;
}
inline bool LoopRequest::has_curlowalarmlimitscp2() const {
  return _internal_has_curlowalarmlimitscp2();
}
inline void LoopRequest::clear_curlowalarmlimitscp2() {
  if (_impl_.curlowalarmlimitscp2_ != nullptr) _impl_.curlowalarmlimitscp2_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::medibus::MedibusRequest& LoopRequest::_internal_curlowalarmlimitscp2() const {
  const ::medibus::MedibusRequest* p = _impl_.curlowalarmlimitscp2_;
  return p != nullptr ? *p : reinterpret_cast<const ::medibus::MedibusRequest&>(
      ::medibus::_MedibusRequest_default_instance_);
}
inline const ::medibus::MedibusRequest& LoopRequest::curlowalarmlimitscp2() const {
  // @@protoc_insertion_point(field_get:medibus.LoopRequest.CurLowAlarmLimitsCP2)
  return _internal_curlowalarmlimitscp2();
}
inline void LoopRequest::unsafe_arena_set_allocated_curlowalarmlimitscp2(
    ::medibus::MedibusRequest* curlowalarmlimitscp2) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.curlowalarmlimitscp2_);
  }
  _impl_.curlowalarmlimitscp2_ = curlowalarmlimitscp2;
  if (curlowalarmlimitscp2) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:medibus.LoopRequest.CurLowAlarmLimitsCP2)
}
inline ::medibus::MedibusRequest* LoopRequest::release_curlowalarmlimitscp2() {
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::medibus::MedibusRequest* temp = _impl_.curlowalarmlimitscp2_;
  _impl_.curlowalarmlimitscp2_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::medibus::MedibusRequest* LoopRequest::unsafe_arena_release_curlowalarmlimitscp2() {
  // @@protoc_insertion_point(field_release:medibus.LoopRequest.CurLowAlarmLimitsCP2)
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::medibus::MedibusRequest* temp = _impl_.curlowalarmlimitscp2_;
  _impl_.curlowalarmlimitscp2_ = nullptr;
  return temp;
}
inline ::medibus::MedibusRequest* LoopRequest::_internal_mutable_curlowalarmlimitscp2() {
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.curlowalarmlimitscp2_ == nullptr) {
    auto* p = CreateMaybeMessage<::medibus::MedibusRequest>(GetArenaForAllocation());
    _impl_.curlowalarmlimitscp2_ = p;
  }
  return _impl_.curlowalarmlimitscp2_;
}
inline ::medibus::MedibusRequest* LoopRequest::mutable_curlowalarmlimitscp2() {
  ::medibus::MedibusRequest* _msg = _internal_mutable_curlowalarmlimitscp2();
  // @@protoc_insertion_point(field_mutable:medibus.LoopRequest.CurLowAlarmLimitsCP2)
  return _msg;
}
inline void LoopRequest::set_allocated_curlowalarmlimitscp2(::medibus::MedibusRequest* curlowalarmlimitscp2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.curlowalarmlimitscp2_;
  }
  if (curlowalarmlimitscp2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(curlowalarmlimitscp2);
    if (message_arena != submessage_arena) {
      curlowalarmlimitscp2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, curlowalarmlimitscp2, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.curlowalarmlimitscp2_ = curlowalarmlimitscp2;
  // @@protoc_insertion_point(field_set_allocated:medibus.LoopRequest.CurLowAlarmLimitsCP2)
}

// optional .medibus.MedibusRequest CurHighAlarmLimitsCP2 = 10;
inline bool LoopRequest::_internal_has_curhighalarmlimitscp2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.curhighalarmlimitscp2_ != nullptr);
  return value;
}
inline bool LoopRequest::has_curhighalarmlimitscp2() const {
  return _internal_has_curhighalarmlimitscp2();
}
inline void LoopRequest::clear_curhighalarmlimitscp2() {
  if (_impl_.curhighalarmlimitscp2_ != nullptr) _impl_.curhighalarmlimitscp2_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const ::medibus::MedibusRequest& LoopRequest::_internal_curhighalarmlimitscp2() const {
  const ::medibus::MedibusRequest* p = _impl_.curhighalarmlimitscp2_;
  return p != nullptr ? *p : reinterpret_cast<const ::medibus::MedibusRequest&>(
      ::medibus::_MedibusRequest_default_instance_);
}
inline const ::medibus::MedibusRequest& LoopRequest::curhighalarmlimitscp2() const {
  // @@protoc_insertion_point(field_get:medibus.LoopRequest.CurHighAlarmLimitsCP2)
  return _internal_curhighalarmlimitscp2();
}
inline void LoopRequest::unsafe_arena_set_allocated_curhighalarmlimitscp2(
    ::medibus::MedibusRequest* curhighalarmlimitscp2) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.curhighalarmlimitscp2_);
  }
  _impl_.curhighalarmlimitscp2_ = curhighalarmlimitscp2;
  if (curhighalarmlimitscp2) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:medibus.LoopRequest.CurHighAlarmLimitsCP2)
}
inline ::medibus::MedibusRequest* LoopRequest::release_curhighalarmlimitscp2() {
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::medibus::MedibusRequest* temp = _impl_.curhighalarmlimitscp2_;
  _impl_.curhighalarmlimitscp2_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::medibus::MedibusRequest* LoopRequest::unsafe_arena_release_curhighalarmlimitscp2() {
  // @@protoc_insertion_point(field_release:medibus.LoopRequest.CurHighAlarmLimitsCP2)
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::medibus::MedibusRequest* temp = _impl_.curhighalarmlimitscp2_;
  _impl_.curhighalarmlimitscp2_ = nullptr;
  return temp;
}
inline ::medibus::MedibusRequest* LoopRequest::_internal_mutable_curhighalarmlimitscp2() {
  _impl_._has_bits_[0] |= 0x00000200u;
  if (_impl_.curhighalarmlimitscp2_ == nullptr) {
    auto* p = CreateMaybeMessage<::medibus::MedibusRequest>(GetArenaForAllocation());
    _impl_.curhighalarmlimitscp2_ = p;
  }
  return _impl_.curhighalarmlimitscp2_;
}
inline ::medibus::MedibusRequest* LoopRequest::mutable_curhighalarmlimitscp2() {
  ::medibus::MedibusRequest* _msg = _internal_mutable_curhighalarmlimitscp2();
  // @@protoc_insertion_point(field_mutable:medibus.LoopRequest.CurHighAlarmLimitsCP2)
  return _msg;
}
inline void LoopRequest::set_allocated_curhighalarmlimitscp2(::medibus::MedibusRequest* curhighalarmlimitscp2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.curhighalarmlimitscp2_;
  }
  if (curhighalarmlimitscp2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(curhighalarmlimitscp2);
    if (message_arena != submessage_arena) {
      curhighalarmlimitscp2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, curhighalarmlimitscp2, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.curhighalarmlimitscp2_ = curhighalarmlimitscp2;
  // @@protoc_insertion_point(field_set_allocated:medibus.LoopRequest.CurHighAlarmLimitsCP2)
}

// optional .medibus.MedibusRequest CurAlarmsCP2 = 11;
inline bool LoopRequest::_internal_has_curalarmscp2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.curalarmscp2_ != nullptr);
  return value;
}
inline bool LoopRequest::has_curalarmscp2() const {
  return _internal_has_curalarmscp2();
}
inline void LoopRequest::clear_curalarmscp2() {
  if (_impl_.curalarmscp2_ != nullptr) _impl_.curalarmscp2_->Clear();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const ::medibus::MedibusRequest& LoopRequest::_internal_curalarmscp2() const {
  const ::medibus::MedibusRequest* p = _impl_.curalarmscp2_;
  return p != nullptr ? *p : reinterpret_cast<const ::medibus::MedibusRequest&>(
      ::medibus::_MedibusRequest_default_instance_);
}
inline const ::medibus::MedibusRequest& LoopRequest::curalarmscp2() const {
  // @@protoc_insertion_point(field_get:medibus.LoopRequest.CurAlarmsCP2)
  return _internal_curalarmscp2();
}
inline void LoopRequest::unsafe_arena_set_allocated_curalarmscp2(
    ::medibus::MedibusRequest* curalarmscp2) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.curalarmscp2_);
  }
  _impl_.curalarmscp2_ = curalarmscp2;
  if (curalarmscp2) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:medibus.LoopRequest.CurAlarmsCP2)
}
inline ::medibus::MedibusRequest* LoopRequest::release_curalarmscp2() {
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::medibus::MedibusRequest* temp = _impl_.curalarmscp2_;
  _impl_.curalarmscp2_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::medibus::MedibusRequest* LoopRequest::unsafe_arena_release_curalarmscp2() {
  // @@protoc_insertion_point(field_release:medibus.LoopRequest.CurAlarmsCP2)
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::medibus::MedibusRequest* temp = _impl_.curalarmscp2_;
  _impl_.curalarmscp2_ = nullptr;
  return temp;
}
inline ::medibus::MedibusRequest* LoopRequest::_internal_mutable_curalarmscp2() {
  _impl_._has_bits_[0] |= 0x00000400u;
  if (_impl_.curalarmscp2_ == nullptr) {
    auto* p = CreateMaybeMessage<::medibus::MedibusRequest>(GetArenaForAllocation());
    _impl_.curalarmscp2_ = p;
  }
  return _impl_.curalarmscp2_;
}
inline ::medibus::MedibusRequest* LoopRequest::mutable_curalarmscp2() {
  ::medibus::MedibusRequest* _msg = _internal_mutable_curalarmscp2();
  // @@protoc_insertion_point(field_mutable:medibus.LoopRequest.CurAlarmsCP2)
  return _msg;
}
inline void LoopRequest::set_allocated_curalarmscp2(::medibus::MedibusRequest* curalarmscp2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.curalarmscp2_;
  }
  if (curalarmscp2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(curalarmscp2);
    if (message_arena != submessage_arena) {
      curalarmscp2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, curalarmscp2, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.curalarmscp2_ = curalarmscp2;
  // @@protoc_insertion_point(field_set_allocated:medibus.LoopRequest.CurAlarmsCP2)
}

// optional .medibus.MedibusRequest DeviceIdentification = 12;
inline bool LoopRequest::_internal_has_deviceidentification() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.deviceidentification_ != nullptr);
  return value;
}
inline bool LoopRequest::has_deviceidentification() const {
  return _internal_has_deviceidentification();
}
inline void LoopRequest::clear_deviceidentification() {
  if (_impl_.deviceidentification_ != nullptr) _impl_.deviceidentification_->Clear();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline const ::medibus::MedibusRequest& LoopRequest::_internal_deviceidentification() const {
  const ::medibus::MedibusRequest* p = _impl_.deviceidentification_;
  return p != nullptr ? *p : reinterpret_cast<const ::medibus::MedibusRequest&>(
      ::medibus::_MedibusRequest_default_instance_);
}
inline const ::medibus::MedibusRequest& LoopRequest::deviceidentification() const {
  // @@protoc_insertion_point(field_get:medibus.LoopRequest.DeviceIdentification)
  return _internal_deviceidentification();
}
inline void LoopRequest::unsafe_arena_set_allocated_deviceidentification(
    ::medibus::MedibusRequest* deviceidentification) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.deviceidentification_);
  }
  _impl_.deviceidentification_ = deviceidentification;
  if (deviceidentification) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:medibus.LoopRequest.DeviceIdentification)
}
inline ::medibus::MedibusRequest* LoopRequest::release_deviceidentification() {
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::medibus::MedibusRequest* temp = _impl_.deviceidentification_;
  _impl_.deviceidentification_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::medibus::MedibusRequest* LoopRequest::unsafe_arena_release_deviceidentification() {
  // @@protoc_insertion_point(field_release:medibus.LoopRequest.DeviceIdentification)
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::medibus::MedibusRequest* temp = _impl_.deviceidentification_;
  _impl_.deviceidentification_ = nullptr;
  return temp;
}
inline ::medibus::MedibusRequest* LoopRequest::_internal_mutable_deviceidentification() {
  _impl_._has_bits_[0] |= 0x00000800u;
  if (_impl_.deviceidentification_ == nullptr) {
    auto* p = CreateMaybeMessage<::medibus::MedibusRequest>(GetArenaForAllocation());
    _impl_.deviceidentification_ = p;
  }
  return _impl_.deviceidentification_;
}
inline ::medibus::MedibusRequest* LoopRequest::mutable_deviceidentification() {
  ::medibus::MedibusRequest* _msg = _internal_mutable_deviceidentification();
  // @@protoc_insertion_point(field_mutable:medibus.LoopRequest.DeviceIdentification)
  return _msg;
}
inline void LoopRequest::set_allocated_deviceidentification(::medibus::MedibusRequest* deviceidentification) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.deviceidentification_;
  }
  if (deviceidentification) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(deviceidentification);
    if (message_arena != submessage_arena) {
      deviceidentification = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, deviceidentification, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  _impl_.deviceidentification_ = deviceidentification;
  // @@protoc_insertion_point(field_set_allocated:medibus.LoopRequest.DeviceIdentification)
}

// repeated .medibus.MedibusRealTimeRequest RealTime = 13;
inline int LoopRequest::_internal_realtime_size() const {
  return _impl_.realtime_.size();
}
inline int LoopRequest::realtime_size() const {
  return _internal_realtime_size();
}
inline void LoopRequest::clear_realtime() {
  _impl_.realtime_.Clear();
}
inline ::medibus::MedibusRealTimeRequest* LoopRequest::mutable_realtime(int index) {
  // @@protoc_insertion_point(field_mutable:medibus.LoopRequest.RealTime)
  return _impl_.realtime_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::medibus::MedibusRealTimeRequest >*
LoopRequest::mutable_realtime() {
  // @@protoc_insertion_point(field_mutable_list:medibus.LoopRequest.RealTime)
  return &_impl_.realtime_;
}
inline const ::medibus::MedibusRealTimeRequest& LoopRequest::_internal_realtime(int index) const {
  return _impl_.realtime_.Get(index);
}
inline const ::medibus::MedibusRealTimeRequest& LoopRequest::realtime(int index) const {
  // @@protoc_insertion_point(field_get:medibus.LoopRequest.RealTime)
  return _internal_realtime(index);
}
inline ::medibus::MedibusRealTimeRequest* LoopRequest::_internal_add_realtime() {
  return _impl_.realtime_.Add();
}
inline ::medibus::MedibusRealTimeRequest* LoopRequest::add_realtime() {
  ::medibus::MedibusRealTimeRequest* _add = _internal_add_realtime();
  // @@protoc_insertion_point(field_add:medibus.LoopRequest.RealTime)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::medibus::MedibusRealTimeRequest >&
LoopRequest::realtime() const {
  // @@protoc_insertion_point(field_list:medibus.LoopRequest.RealTime)
  return _impl_.realtime_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace medibus

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_medibus_2eproto
